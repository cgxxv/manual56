## 22.8 MySQL C API

通过C API可以调用MySQL通信协议，从而可以访问数据库内容。C API代码随MySQL分发，具体功能在libmysqlclient中实现。
大多数客户端API都是使用libmysqlclient来跟MySQL服务器通信（Connector/J和Connector/Net除外）。于是你的客户端程序也能共享其他客户端程序的的环境变量，因为这些环境变量都是在libmysqlclient所定义的。
如何编译使用了C API的客户端程序参考22.8.4.1节。线程编程方面请参考22.8.4.2节。编写同时包含客户端和服务端的独立程序（无需跟外部MySQL服务器通信）的方法，请参考22.7节。

注意。升级之后，如果编译好的程序突然出现了“command out of sync”或者发送了非预期的核心转储(core dump)等问题，很有可能是因为编译过程中使用了老的头文件或者库文件。这个时候可以检查一下mysql.h和libmysqlclient.a的日期，以确认这些文件都是最新版本的。如果确认了是版本问题，用新版本的头文件和库文件重新编译一下程序。如果MySQL动态库的大版本发生了变化，编译中使用了MySQL动态库的程序也需要重新编译。更多兼容性相关信息，请参考22.8.4.3节。

客户端的通信缓存大小有个最大限制。初始大小是16KB，需要的时候会自动增长到最大值（默认16MB）。正因为是按需增长，增加最大限制本身并不意味着更多的资源消耗。缓存区大小检查主要是为了预防过长的查询语句或者过大的结果数据包。
缓存必须要足够大，至少要能容纳一条单一查询语句（客户端到服务端的流量），也要能装下一行查询结果（服务端到客户端的流量）。为了处理查询和和查询结果，必要时缓存会自动增加以至达到最大值。例如，你的BLOB类型字段包含了16MB的数据，那么客户端和服务端的缓存大小都必须至少16MB。编译进了客户端库的默认最大值是1GB，但是服务端的默认最大值只有1MB。在服务程序启动时候，通过设置max_allow_packet字段可以增加这个值。详见8.11.2节。
每次查询之后，服务端的缓存大小缩减到528B，这个值由net_buffer_length定义。在客户端，每个连接使用的缓存直到连接关闭才会被回收。
