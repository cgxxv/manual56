## 22.8.9. C API预处理语句数据结构

预处理语句使用几种数据结构：

* 传递一个 **MYSQL** 连接句柄给 *mysql_stmt_init()* ，得到一个指向 **MYSQL_STMT** 数据结构的指针，即语句句柄。使用这一结构可以做更多的操作。把 **MYSQL_STMT** 指针和语句字符串传递给 *mysql_stmt_prepare()* 以对语句进行预处理。

* 要给预处理语句传递参数，创建一个 **MYSQL_BIND** 结构，并将其和参数一起传递给 *mysql_stmt_bind_param()* 。要接收输出的字段值，创建 **MYSQL_BIND** 结构并将其传递给 *mysql_stmt_bind_result()* 。

* **MYSQL_TIME** 结构用来传递时间相关数据。


下面的讨论详细描述各数据类型。相关范例，参考 [22.8.11.10，mysql_stmt_execute()]() 以及 [22.8.11.11，mysql_stmt_fetch()]() 。

* **MYSQL_STMT**

该结构时预处理语句的句柄。通过 *mysql_stmt_init()* 创建。该句柄用于对该语句的后续操作，直到调用了 *mysql_stmt_close()* ，这此后该句柄就失效了。

该结构没有哪个成员被设计成让应用程序直接使用。应用程序也不应该拷贝该结构。对于拷贝的可用性没有任何保证。

多个语句句柄可以关联到同一条连接上。数量极限取决于可用的系统资源。

* **MYSQL_BIND**

	该结构既可用于语句的输入（向服务端传递数据），也可用于输出（从服务端返回结果）：

	* 对于输入，使用 **MYSQL_BIND** 结构调用 *mysql_stmt_bind_param()* 将参数绑定到缓存上，以供 *mysql_stmt_execute()* 使用。
	
	* 对于输出，使用 **MYSQL_BIND** 结构调用 *mysql_stmt_bind_result()* 将缓存绑定到数据集字段上，以供 *mysql_stmt_fetch()* 使用。
	
	使用该结构之前，先用0对其内容进行填充，然后适当的设置它的成员。例如，声明以及初始化一个包含3个 **MYSQL_BIND** 的数组，使用以下的代码：
	
	```c
	MYSQL_BIND bind[3];
	memset(bind, 0, sizeof(bind));
	```
	
	该结构包含以下成员可被客户端程序使用。对于有些成员，使用的方式取决于该结构是用于输入还是输出。
	
	* *enum enum_field_types buffer_type*
		
		缓存区的类型。该成员表示该C语言数据类型是跟语句参数还是结构集字段绑定。对于输入，该成员表示该结构包含发给服务端的数据。对于输出，表示从服务端收到的数据将会存到该结构。所有可用的 *buffer_type* 值，参考 [22.8.9.1，C API预处理语句类型代码]() 。
	
	* *void *buffer*
	
		指向用于数据传输的缓冲区的指针。也就是变量的地址。
		
		对于输入，其中存储的数据用作语句参数。当调用 *mysql_stmt_execute()* 时，MySQL使用此处的值替代语句中相应的参数标记（在语句字符串中以 *?* 表示）。
		
		对于输出，此处存放结果集字段值。当调用 *mysql_stmt_fetch()* ，MySQL将结果集中当前记录的字段存到这里。当调用返回之后就可以访问该值了。
		
		为了最小化C语言值和SQL值直接的类型转换，C变量的数据类型应该跟相应的SQL值类似：
		
		* 对应数值型数据， *buffer* 应该指向C数值类型的变量。对于整数变量（单字节可能用 *char* ，较大的值使用整型），必须设置 *is_unsigned* 变量以表示变量是否是无符号的。下文将详述。
		
		* 对于字符（非二进制）和二进制字符串， *buffer* 应指向字符型的缓冲区。
		
		* 对于日期和时间类型， *buffer* 应该指向一个 **MYSQL_TIME** 结构。
		
	* *unsigned long buffer_length*
	
		*\*buffer* 的大小，以字节计。这表示了缓冲区可以存储的最大数据量。对于字符和二进制数据，当调用 *mysql_stmt_bind_param()* 指定输入的时候，该成员表示缓冲区的长度，当调用 *mysql_stmt_bind_result()* 时，该成员表示缓冲区能存储数据的最大长度。
		
	* *unsigned long *length*
	
		一个指向 *unsigned long* 变量的指针，表示 *\*buffer* 中实际存储数据的长度。 *length* 用于字符或者二进制C数据。
		
		当绑定参数作为输入时，设置 *\*length* 为 *\*buffer* 中存储的参数值的实际长度，它将被 *mysql_stmt_execute()* 使用。
		
		当作为输出时，当调用 *mysql_stmt_fetch()* ，MySQL会设置 *\*length* 。 *mysql_stmt_fetch()* 的返回值决定了该如何理解 *\*length* 。
		
		* 如果返回值为0， *\*length* 表示参数值的真实长度。
		
		* 如果返回值为 **MYSQL_DATA_TRUNCATED** ， *\*length* 表示参数值未截断之前的长度。在此情况下， *\*length* 和 *buffer_length* 的最小值才是真实的值的长度。
		
		对于数值类型和时间类型，该成员可以忽略，因为 *buffer_type* 决定了数据的长度。
		
		如果想在将数据读取回来之前就确定值的长度，参考 [22.8.11.11，mysql_stmt_fetch()]() 。
		
	* *my_bool *is_null*
	
		该成员指向一个 *my_bool* 变量，如果值为 **NULL** 该变量则为true，否则为false。用作输入时，如果你想传递 **NULL** 作为参数值，则将 *\*is_null* 设置为true。
	
		*is_null* 之所以是一个boolean量的指针而不是boolean量，是为了给指定 **NULL** 值提供更多的灵活性：
		
		* 如果数据总是为 **NULL** ，在绑定字段时将 *buffer_type* 置为 **MYSQL_TYPE_NULL** 。 *MYSQL_BIND** 的其他成员，包括 *is_null* 对此不会有任何影响。
		
		* 如果数据总是 **NOT NULL** ，设置 *is_null = (my_bool *) 0* ，并且将其他成员设置为合适的值。
		
		* 对于其他情况，合理的设置其他成员的值，同时将 *is_null* 设置为一个 *my_bool* 类型变量的地址。根据和传递的值是否为 **NULL** 来设置该变量的值。
		
		对于输出，读取一行时，MySQL会根据语句返回的结果集字段值是否为 **NULL** 将 *is_null* 指向的值设置为true或者false。
		
	* *my_bool is_unsigned*
	
		该成员适用于可能为 *unsigned* （ *char* ， *short int* ， *int* ， *long long int* ）的C变量。根据 *buffer* 指向的值是否为 *unsigned* 将该成员设置为true或者false。例如绑定一个 *signed char* 变量到 *buffer* ，指定类型码为 **MYSQL_TYPE_TINY** 并且设置 *is_unsigned* 为false。相反如果绑定一个 *unsigned char* 变量，类型码不变，但是 *is_unsigned* 必须为true。（对于 *char* ，因为其符合是未定义的，所以最好使用 *signed char* 或者 *unsigned char* 显式指定其符号。）
		
		*is_unsigned* 只适用于客户端的C语言变量。跟服务端相应SQL值的符号没有任何关系。例如，使用 *int* 给 **BIGINT UNSIGNED** 传递值时， *is_unsigned* 必须为false因为 *int* 是有符号类型。如果使用 *unsigned int* 给 **BIGINT** 字段传递值时， *is_unsigned* 必须为true，因为 *unsigned int* 时无符号类型。MySQL在两个方向上都会对有符号和无符号做恰当的转换，尽管发生截断时可能会发出警告。
		
	* *my_bool *error*
	
		对于输出，将此成员指向一个 *my_bool* 变量，以指示一个记录获取操作之后将参数截断信息记录在此。当开启了截断报告时，如果参数发生了截断 *mysql_stmt_fetch()* 将返回 **MYSQL_DATA_TRUNCATED** 而且相应的 **MYSQL_BIND** 结构中的 _*error_ 将被设置为true。截断意味着符号位或者显著位的丢失，也可能是字符串太长装不进字段。截断报告时默认开启的，可以以 **MYSQL_REPORT_DATA_TRUNCATION** 调用 *mysql_options()* 进行修改。
		
		
* **MYSQL_TIME**

	该结构用于向服务端发送或者从服务端接收 **DATE** ， **TIME** ， **DATETIME** 和 **TIMESTAMP** 类型的数据。
	
	将 *buffer* 成员指向一个 **MYSQL_TIME** 结构，并且将 *buffer_type* 成员设置为合适的时间类型（ **MYSQL_TYPE_TIME** ， **MYSQL_TYPE_DATE** ， **MYSQL_TYPE_DATETIME** ， **MYSQL_TYPE_TIMESTAMP** ）。
	
	**MYSQL_TIME** 包含以下成员：
	
	</table>
	<tr><th>成员</th><th>描述</th></tr>
	<tr><td>unsigned int year</td><td>年</td></tr>
	<tr><td>unsigned int month</td><td>月</td></tr>
	<tr><td>unsigned int day</td><td>日</td></tr>
	<tr><td>unsigned int hour</td><td>时</td></tr>
	<tr><td>unsigned int minute</td><td>分</td></tr>
	<tr><td>unsigned int second</td><td>秒</td></tr>
	<tr><td>my_bool neg</td><td>表示时间是否为负值</td></tr>
	<tr><td>unsigned long second_part</td><td>微妙（MySQL 5.6.4之前未使用）</td></tr>
	</table>
	
	对于不同类型的时间值， **MYSQL_TIME** 结构使用了不同的成员。 *year* ， *month* 和 *day* 用于 **DATE** ， **DATETIME** ， **TIMESTAMP** 。 *hour* ， *minute* ， *second* 用于 **TIME** ， **DATETIME** ， **TIMESTAMP** 。参考 [22.8.19，C API预处理语句对日期和时间值的处理]() 。