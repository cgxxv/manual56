### 22.2.5. Connector/Net编程

Connector/Net包含几个用于连接数据库、执行查询语句和管理查询结果。

以下是Connector/Net的主要类： 
 
* _MySqlCommand_：代表一个用于针对执行一个MySQL数据库的SQL语句。
* _MySqlCommandBuilder_：自动生成单表命令用于调和一个数据集变化与相关的MySQL数据库。
* _MySqlConnection_：表示一个到MySQL服务器数据库的打开的连接。
* _MySqlDataAdapter_：表示一个数据命令集合与一个用于填充一个数据集合和更新一个MySQL数据库的数据库连接。
* _MySqlDataReader_：提供了一种方法来从一个MySQL数据库读取一个单向的流。
* _MySqlException_：当MySQL返回一个错误的时候，抛出该异常。
* _MySqlHelper_：使提供者更加容易的工作的辅助类。
* _MySqlTransaction_：表示一个数据库产生的SQL事物。

在以下章节，你会学到一些对于Connector/Net的一般用例，包括BLOB处理、数据处理和使用Connector/Net与形如Crystal报表的常见工具。

#### 22.2.5.1. Connecting to MySQL Using Connector/Net

一个.net应用程序和MySQL服务器之间的交互是通过一个MySqlConnection对象来实现的。

你的应用程序能跟服务器交互之前，必须实例化、配置和打开一个MySqlConnection对象。

甚至当使用_MySqlHelper_类，使得一个_MySqlconnection_对象被辅助类所创建。

本章描述了如何使用MySqlConnection对象连接到MySQL。

[22.2.5.2]: ./docs/Chapter_22/22.2.5_ConnectorNet_Programming.md#22.2.5.2
#### 22.2.5.2. 创建一个Connector/Net连接字符串

_MySqlConnection_对象使用一个连接字符串进行配置。一个连接字符串包含几个被分号隔开的键值对。在每一个键值对里，选项名和它对应的值用等号连接的。关于选项名列表在在字符串中的用法，参考[章节22.2.6, “Connector/Net连接字符串选项参考”](../Chapter_22/22.2.6_ConnectorNet_Connection_String_Options_Reference.md)

以下是一个连接字符串的例子：

	Server=127.0.0.1;Uid=root;Pwd=12345;Database=test;

在这个例子里，_MySqlConnection_对象被配置为连接到一个使用的用户名是_root_和密码是_12345_的在_127.0.0.1_上的MySQL服务。对于所有语句的默认数据库是_test_数据库。

>__注解__
>
虽然使用'?'这种老的模式仍然被支持，但是使用'@'符号来表示参数是现在首选的方法。为了避免冲突，当在用户变量的组合中使用'@'符号的时候，请参照[章节22.2.6, “Connector/Net连接字符串选项参考”][22.2.6]中的_容许用户变量_连接字符串选项。_Old Syntax_连接字符串选项已经不被赞成使用。

##### 22.2.5.2.1. 打开一个连接

一旦你已经创建了一个连接字符串，它能够用于打开一个到MySQL服务的连接。

以下的代码是用于创建一个_MySqlConnection_对象，指定连接字符串并且打开这个连接。

Connector/Net也能够使用本地Windows身份验证插件进行连接。详细参照[章节 22.2.5.5, “使用Windows本地身份验证插件”][22.2.5.5]。

你可以通过写自己的插件来进一步扩展验证机制。详细参照[章节 22.2.5.6, “编写一个客户端身份验证插件”][22.2.5.6]。

**Visual Basic示例**  

	Dim conn As New MySql.Data.MySqlClient.MySqlConnection
	Dim myConnectionString as String

	myConnectionString = "server=127.0.0.1;" _
	& "uid=root;" _
            & "pwd=12345;" _
            & "database=test;"

	Try
  	  conn.ConnectionString = myConnectionString
  	  conn.Open()

	Catch ex As MySql.Data.MySqlClient.MySqlException
	  MessageBox.Show(ex.Message)
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	string myConnectionString;

	myConnectionString = "server=127.0.0.1;uid=root;" +
    	"pwd=12345;database=test;";

	try
	{
    	conn = new MySql.Data.MySqlClient.MySqlConnection();
    	conn.ConnectionString = myConnectionString;
    	conn.Open();
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
    	MessageBox.Show(ex.Message);
	}

你也可以把连接字符串传递到_MySqlConnection_类的构造函数中。

**Visual Basic示例**

	Dim myConnectionString as String

	myConnectionString = "server=127.0.0.1;" _
              & "uid=root;" _
              & "pwd=12345;" _
              & "database=test;"

	Try
    	Dim conn As New MySql.Data.MySqlClient.MySqlConnection(myConnectionString)
    	conn.Open()
	Catch ex As MySql.Data.MySqlClient.MySqlException
   		MessageBox.Show(ex.Message)
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	string myConnectionString;

	myConnectionString = "server=127.0.0.1;uid=root;" +
    	"pwd=12345;database=test;";

	try
	{
    	conn = new MySql.Data.MySqlClient.MySqlConnection(myConnectionString);
    	conn.Open();
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	    MessageBox.Show(ex.Message);
	}

一旦连接被打开，它就可以用于其他的Connector/Net类去和MySQL服务进行交流。

##### 22.2.5.2.2. 处理连接错误

因为连接一个外部服务是不可预知的，所以添加错误处理对于你的.NET应用程序是十分重要的。当有一个错误连接产生，_MySqlConnection_类就会返回一个_MySqlException_对象。这个当产生错误的时候的有趣的对象有两个属性：

* _Message_：一个描述当前异常的信息。
* _Number_：MySQL的错误代号。

当处理错误产生，你可以基于错误代号相应你的应用程序。当连接时，有如下两个最常见的错误代号：

* _0_：不能连接到服务。
* _1045_：无效的用户名或密码。

接下来的代码展示了如何适应基于实际错误的应用程序的相应：

**Visual Basic示例**

	Dim myConnectionString as String

	myConnectionString = "server=127.0.0.1;" _
          & "uid=root;" _
          & "pwd=12345;" _
          & "database=test;"

	Try
    	Dim conn As New MySql.Data.MySqlClient.MySqlConnection(myConnectionString)
    	conn.Open()
	Catch ex As MySql.Data.MySqlClient.MySqlException
    	Select Case ex.Number
        	Case 0
            	MessageBox.Show("Cannot connect to server. Contact administrator")
        	Case 1045
            	MessageBox.Show("Invalid username/password, please try again")
    	End Select
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	string myConnectionString;

	myConnectionString = "server=127.0.0.1;uid=root;" +
    	"pwd=12345;database=test;";

	try
	{
    	conn = new MySql.Data.MySqlClient.MySqlConnection(myConnectionString);
    	conn.Open();
	}
    	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
    	switch (ex.Number)
    	{
        	case 0:
            	MessageBox.Show("Cannot connect to server.  Contact administrator");
            	break;
        	case 1045:
            	MessageBox.Show("Invalid username/password, please try again");
            	break;
    	}
	}

>重要提示  
注意如果你要是使用读语言数据库的话，就必须在连接字符串中指定字符集。如果你不指定字符集，连接就会默认为_latin1_字符集。你可以把指定字符集作为连接字符串的一部分，如下例:

	MySqlConnection myConnection = new MySqlConnection("server=127.0.0.1;uid=root;" +
	"pwd=12345;database=test;Charset=latin1;");

##### 22.2.5.2.3. Using GetSchema on a Connection

连接对象的_GetSchema()_方法可以用于取得关于数据库当前连接的schema信息。schema信息以_DataTable_的形式返回。这个schema信息被组织成一个数字集合。不同形式的_GetSchema()_方法可以根据信息请求被使用。这有三种形式的_GetSchema()_方法：

* _GetSchema()_ - 该调用会返回一个可用集合。
* _GetSchema(String)_ - 该调用会返回集合中指定字符串参数的信息。如果字符串“MetaDataCollections”被使用，那么一个所有可用集合的列表将被返回。这就跟调用没用任何参数的_GetSchema()_一样。
* _GetSchema(String, String[])_ - 在这个调用中第一个字符串参数代表集合名，并且第二个参数代表一个约束值的字符串数组。约束值限制将要返回的数据的量。约束值有更多详细的解释在[Microsoft .NET documentation](http://msdn.microsoft.com/en-us/library/ms254934(VS.80).aspx)里。

###### 22.2.5.2.3.1. 集合

集合可以被广泛的分为两类：通用于所有的数据提供者的集合和特定于一个特定的提供者的集合。

**普通的**

以下集合是通用于所有数据提供者的：

* MetaDataCollections
* DataSourceInformation
* DataTypes
* Restrictions
* ReservedWords

**特定于提供程序的**

以下是MySQL Connector/Net当前提供的除通用集合之上的集合：

* Databases
* Tables
* Columns
* Users
* Foreign Keys
* IndexColumns
* Indexes
* Foreign Key Columns
* UDF
* Views
* ViewColumns
* Procedure Parameters
* Procedures
* Triggers

***示例代码***

一个可用集合列表可以用下面的代码获得：

	using System;
	using System.Data;
	using System.Text;
	using MySql.Data;
	using MySql.Data.MySqlClient;

	namespace ConsoleApplication2
	{
    	class Program
    	{

        	private static void DisplayData(System.Data.DataTable table)
        	{
            	foreach (System.Data.DataRow row in table.Rows)
            	{
                	foreach (System.Data.DataColumn col in table.Columns)
                	{
                    	Console.WriteLine("{0} = {1}", col.ColumnName, row[col]);
                	}
                	Console.WriteLine("============================");
            	}
        	}

        	static void Main(string[] args)
        	{

            	string connStr = "server=localhost;user=root;database=world;port=3306;password=******;";
            	MySqlConnection conn = new MySqlConnection(connStr);

            	try
            	{
                	Console.WriteLine("Connecting to MySQL...");
                	conn.Open();

                	DataTable table = conn.GetSchema("MetaDataCollections");
                	//DataTable table = conn.GetSchema("UDF");
                	DisplayData(table);

                	conn.Close();
            	}
            	catch (Exception ex)
            	{
                	Console.WriteLine(ex.ToString());
            	}
            	Console.WriteLine("Done.");
        	}
    	}
	}

关于更多的_GetSchema()_方法和schema集合的信息可以再[Microsoft .NET documentation](http://msdn.microsoft.com/en-us/library/kcax58fh(VS.80).aspx)找到。

#### 22.2.5.3. 使用MySqlCommand

一个_MySqlCommand_包含有与它关联的_CommandText_和_CommandType_属性。_CommandText_依赖于_CommandType_的设置进行不同的处理。_CommandType_可以是其中任意一个：

1. Text - 一个SQL文本命令(默认)
2. StoredProcedure - 一个存储过程的名称
3. TableDirect - 一个表名称(新出现在Connector/Net 6.2)

默认的_CommandType_和_Text_被用于查询和其他的SQL命令。关于这个的一些例子可以在[Section 22.2.4.1.2, “MySqlCommand对象”][22.2.4.1.2]。

[22.2.4.1.2]: ./docs/Chapter_22/22.2.4_ConnectorNet_Tutorials.md#22.2.4.1.2

如果_CommandType_被设置到_TableDirect_中，当你调用Execute方法时，所有的命名的表的行和列将被返回。实际上，这个命令在指定的表上执行一个_SELECT \*_。_CommandText_属性设置为表名来查询。这被以下代码片段说明：

	...
	MySqlCommand cmd = new MySqlCommand();
	cmd.CommandText = "mytable";
	cmd.Connection = someConnection;
	cmd.CommandType = CommandType.TableDirect;
	MySqlDataReader reader = cmd.ExecuteReader();
	while (reader.Read())
	{
		Console.WriteLn(reader[0], reader[1]...);
	}
	...

使用存储过程的CommandType的示例可以在[Section 22.2.5.9, “使用Connector/Net访问存储过程”][22.2.5.9]中找到。

命令可以有一个超时与它们相关联。如果你可能不想一个命令占用过多的时间，这是很有用的。超时可以通过_CommandTimeout_属性来设置。以下的代码片段设置了一个一分钟的超时。

	MySqlCommand cmd = new MySqlCommand();
	cmd.CommandTimeout = 60;

默认值是30秒。避免值为0，其表明一个不确定的等待。使用连接字符串_Default Command Timeout_来改变默认的命令超时。

在MySQL Connector/Net 6.2之前，_MySqlCommand.CommandTimeout_包括不涉及连接器的直接使用用户处理时间。通过一个在_CommandTimeout_秒后触发的.NET定时器来实现超时。该定时器消耗一个线程。

MySQL Connector/Net 6.2引入符合微软如何处理_SqlCommand.CommandTimeout_的超时。该属性是对于所有的在命令执行和结果处理之间的网络读写的积累超时。在第一行被返回之后，并且不包含用户处理时间，仅仅有IO操作，在_MySqlReader.Read_方法中仍然会发生一个超时。6.2的实现使用底层流超时设施，所以效率更高，因为它不要求额外的定时器线程作为使用优先实现的实例。

更多详细内容可以在有关的_微软文档_中找到。

#### 22.2.5.4. 使用Connector/Net和连接池
Connector/Net支持连接池在数据库密集型应用程序上以获得更好的性能和可扩展性。这是默认启用的。你可以关掉它或者使用连接字符串选项_Pooling_,_Connection Reset_,_Connection Lifetime_,_Cache Server Properties_,_Max Pool Size_和_Min Pool Size_来调整它的性能特征。关于进一步信息请参照[章节22.2.5.2, “创建一个Connector/Net连接字符串”][22.2.5.2]

当客户端设置一个_MySqlConnection_的时，连接池通过保持本地连接到服务器生存。随后，如果一个新的_MySqlConnection_对象被打开，它将会从连接池中被创建，而不是创建一个新的本地连接。这就提高了性能。

**指南**

为了有计划的工作，最好让连接池系统来管理所有的连接。不创建一个全局的可访问的_MySqlConnection_示例，并且手动的打开和关闭它。随着这种方式的干扰池的运行，并且可能导致不可预知的结果，甚至异常。

一种简化方法是避免手动地创建一个_MySqlConnectionobject_对象。反而用把连接字符串作为参数的overloaded方法。使用这种方法，Connector/Net会自动地创建、打开、关闭和销毁连接，使用连接池系统的性能最好。

类型化数据集与_MembershipProvider_和_RoleProvider_类使用这种方法。大部分类拥有把_MySqlConnection_当做参数的方法，而且还有把一个连接字符串当做参数的方法。这个包括_MySqlDataAdapter_。

代替手动地创建_MySqlCommand_对象，你可以使用_MySqlHelper_类的静态方法。这些把一个连接字符串作为一个参数，并且它们完全支持连接池。

**资源使用**

启动MySQL Connector/Net 6.2，会有一个每运行三分钟就从池中删除超过三分钟而空闲的连接的后台作业。该池清理释放客户端和服务器端的资源。这是因为在客户端每个连接使用一个套接字，并且在服务器端每个连接使用一个套接字和一个线程。

在这个改变之前，连接绝对不会从池中删除，并且该池总是包含打开连接的峰值个数。例如，一个web应用程序达到1000个并发数据库连接就会消耗1000个线程，并且在服务器中有1000个打开的套接字，而不从连接池中释放那些资源。注意，如果在线程池中的连接数量少于或等于用_Min Pool Size_连接字符串参数设置的值，无论多么老的连接也不会关闭。

[22.2.5.5]: ./docs/Chapter_22/22.2.5_ConnectorNet_Programming.md#22.2.5.5
#### 22.2.5.5. 使用Windows本地身份验证插件

自Connector/Net 6.4.4和MySQL 5.5.16/5.6.10起，Connector/Net可以使用Windows本地身份认证插件来认证一个MySQL服务器。已经登录到Windows的用户可以连接到MySQL客户端程序，因为服务器根据在它们环境中无需指定一个附加的密码的消息。关于身份验证插件的背景和使用信息，请参照[章节6.3.7.6, “Windows本地身份验证插件”](/Chapter06/6.3.7.6_The_Windows_Native_Authentication_Plugin#6.3.7.6)。

该接口与_MySql.Data.MySqlClient_对象相配。用_yes_或者_sspi_的值使能够传递_Integrated Security_到连接字符串。

传递一个用户ID是可选择的。当Windows身份验证被设置，一个MySQL用户被创建并且被配置为使用Windows身份验证。默认的情况下，这个用户被命名为_auth_windows_,但是可以被定义为其他的名字。如果默认名称被使用，那么从Connector/Net传递该用户ID到连接字符串是可选的，因为它将使用_auth_windows_这个用户。否则，名字必须使用标准用户ID元素传递到连接字符串。

[22.2.5.6]: ./docs/Chapter_22/22.2.5_ConnectorNet_Programming.md#22.2.5.6
#### 22.2.5.6. 编写一个客户端身份验证插件

有特殊安全需求的高级用户可以为Connector/Net应用程序创建他们自己的身份验证插件。你可以扩展握手协议，添加自定义逻辑。该功能需要Connector/Net 6.6.3或者更高版本，且需要MySQL 5.5.16或者更高版本。关于MySQL的身份验证插件的背景和使用信息，请参见[章节23.2.3.7, “身份验证插件”](/docs/Chapter_23/23.2.3.7_Authentication_Plugins#23.2.3.7)和[章节23.2.4.9, “编写身份验证插件”](/docs/Chapter_23/23.2.4.9_Writing_Authentication_Plugins#23.2.4.9)。

要编写自定义的认证插件，您将需要一个MySql.Data.dll组件的引用。在命名空间_MySql.Data.MySqlClient.Authentication_中与编写身份验证插件有关的类是可利用的。

**自定义身份验证插件是怎么工作的**

握手期间在某些点上_MySqlAuthenticationPlugin_的内部方法

	void Authenticate(bool reset)

被调用。该方法轮流调用当前插件的几个可重写方法。

**创建身份验证插件类**

你把身份验证插件逻辑放进一个派生于_MySql.Data.MySqlClient.Authentication.MySqlAuthenticationPlugin_的新类。以下方法是可以被重写的。

	protected virtual void CheckConstraints()
	protected virtual void AuthenticationFailed(Exception ex)
	protected virtual void AuthenticationSuccessful()
	protected virtual byte[] MoreData(byte[] data)
	protected virtual void AuthenticationChange()
	public abstract string PluginName { get; }
	public virtual string GetUsername()
	public virtual object GetPassword()
	protected byte[] AuthData;

以下是对每个方法的简单说明：

	/// <summary>
	/// This method must check authentication method specific constraints in the 
	environment and throw an Exception
	/// if the conditions are not met. The default implementation does nothing.
	/// </summary>
	protected virtual void CheckConstraints()

	/// <summary>
	/// This method, called when the authentication failed, provides a chance to 
	plugins to manage the error
	/// the way they consider decide (either showing a message, logging it, etc.).
	/// The default implementation wraps the original exception in a MySqlException 
	with an standard message and rethrows it.
	/// </summary>
	/// <param name="ex">The exception with extra information on the error.</param>
	protected virtual void AuthenticationFailed(Exception ex)

	/// <summary>
	/// This method is invoked when the authentication phase was successful accepted 
	by the server.
	/// Derived classes must override this if they want to be notified of such 
	condition.
	/// </summary>
	/// <remarks>The default implementation does nothing.</remarks>
	protected virtual void AuthenticationSuccessful()

	/// <summary>
	/// This method provides a chance for the plugin to send more data when the 
	server requests so during the 
	/// authentication phase. This method will be called at least once, and more 
	than one depending upon whether the
	/// server response packets have the 0x01 prefix.
	/// </summary>
	/// <param name="data">The response data from the server, during the 
	authentication phase the first time is called is null, in 
	subsequent calls contains the server response.</param>
	/// <returns>The data generated by the plugin for server consumption.</returns>
	/// <remarks>The default implementation always returns null.</remarks>
	protected virtual byte[] MoreData(byte[] data)

	/// <summary>
	/// The plugin name.
	/// </summary>
	public abstract string PluginName { get; }

	/// <summary>
	/// Gets the user name to send to the server in the authentication phase.
	/// </summary>
	/// <returns>An string with the user name</returns>
	/// <remarks>Default implementation returns the UserId passed from the 
	connection string.</remarks>
	public virtual string GetUsername()

	/// <summary>
	/// Gets the password to send to the server in the authentication phase. This 
	can can be an string or a
	/// </summary>
	/// <returns>An object, can be byte[], string or null, with the password.
	</returns>
	/// <remarks>Default implementation returns null.</remarks>
	public virtual object GetPassword()

	/// <summary>
	/// The authentication data passed when creating the plugin. 
	/// For example in mysql_native_password this is the seed to encrypt the 
	password.
	/// </summary>
	protected byte[] AuthData;

**身份认证插件实例**

这里有个展示如何创建身份验证插件，然后用配置文件的方法启用它的例子。以下是这些步骤：

1.创建一个控制台应用程序，并添加一个参考_MySql.data.dll_。
2.设计如下主程序：

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using MySql.Data.MySqlClient;

	namespace AuthPluginTest
	{
		class Program
		{
			static void Main(string[] args)
			{
				// Customize the connection string as necessary.
				MySqlConnection con = new MySqlConnection("server=localhost; 
				database=test; user id=myuser; password=mypass");
				con.Open();
				con.Close();
			}
		}
	}	

3.创建你的插件类。在这个例子中，我们只要使用相同的代码从原来的插件添加一个本地密码插件的“供选择的”实现。我们把我们的类命名为_MySqlNativePasswordPlugin2_：

	using System.IO;
	using System;
	using System.Text;
	using System.Security.Cryptography;
	using MySql.Data.MySqlClient.Authentication;
	using System.Diagnostics;

	namespace AuthPluginTest
	{
		public class MySqlNativePasswordPlugin2 : MySqlAuthenticationPlugin
		{
			public override string PluginName
			{
				get { return "mysql_native_password"; }
			}

			public override object GetPassword()
			{
				Debug.WriteLine("Calling MySqlNativePasswordPlugin2.GetPassword");
				return Get411Password(Settings.Password, AuthData);
			}

			/// <summary>
			/// Returns a byte array containing the proper encryption of the 
			/// given password/seed according to the new 4.1.1 authentication scheme.
			/// </summary>
			/// <param name="password"></param>
			/// <param name="seed"></param>
			/// <returns></returns>
			private byte[] Get411Password(string password, byte[] seedBytes)
			{
				// if we have no password, then we just return 1 zero byte
				if (password.Length == 0) return new byte[1];

				SHA1 sha = new SHA1CryptoServiceProvider();

				byte[] firstHash = sha.ComputeHash(Encoding.Default.GetBytes(password));
				byte[] secondHash = sha.ComputeHash(firstHash);

				byte[] input = new byte[seedBytes.Length + secondHash.Length];
				Array.Copy(seedBytes, 0, input, 0, seedBytes.Length);
				Array.Copy(secondHash, 0, input, seedBytes.Length, secondHash.Length);
				byte[] thirdHash = sha.ComputeHash(input);

				byte[] finalHash = new byte[thirdHash.Length + 1];
				finalHash[0] = 0x14;
				Array.Copy(thirdHash, 0, finalHash, 1, thirdHash.Length);

				for (int i = 1; i < finalHash.Length; i++)
				  finalHash[i] = (byte)(finalHash[i] ^ firstHash[i - 1]);
				return finalHash;
			}
		}
	}

4.请注意，该插件实现仅重写_GetPassword_，并提供一个实现，使用4.1协议对密码进行加密。我们也把下面的一行放进_GetPassword_上：

	Debug.WriteLine("Calling MySqlNativePasswordPlugin2.GetPassword");

来提供确认该插进被有效地利用。（你也可以再该方法打一个断点。）

5.在配置文件中启用新插件：

	<?xml version="1.0"?>
	<configuration>
	<configSections>
		<section name="MySQL" type="MySql.Data.MySqlClient.MySqlConfiguration, 
		MySql.Data"/>
	</configSections>
	<MySQL>
		<AuthenticationPlugins>
			<add name="mysql_native_password" 
	type="AuthPluginTest.MySqlNativePasswordPlugin2, AuthPluginTest"></add>
		</AuthenticationPlugins> 
	</MySQL>
	<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/>
	</startup></configuration>

6.运行该应用程序。在Visual Studio中，你会在debug窗口看到_Calling MySqlNativePasswordPlugin2.GetPassword_的消息。

7.如果你有需要的话，可以重写更多的方法，继续增强身份验证逻辑。

[22.2.5.9]: ./docs/Chapter_22/22.2.5_ConnectorNet_Programming.md#22.2.5.9
#### 22.2.5.9. 使用Connector/Net访问存储过程