## 22.8.5. C API的数据结构
本节描述C API数据结构，预处理语句相关数据结构除外。后者将会在 [22.8.9，C API预处理语句数据结构]() 详细说明。

*	**MYSQL**

	该结构表示数据库连接句柄。几乎所有MySQL函数都要用到它。对该结构的拷贝的可用性没有任何保证，所以请不要尝试拷贝该结构。
*	**MYSQL_RES**

	该结构表示所有以行作为返回的查询（**SELECT**，**SHOW**，**DESCRIBLE**，**EXPLAIN**）的查询结果。在本节以下部分，此类查询的返回信息被称为结果集	
*	**MYSQL_ROW**

	结构是对一行信息的“类型安全（type-safe）”表达。在目前，它是以计数字符串数组形式实现的。（不能将其视为null结尾字符串，因为如果字段值包含二进制数据，则其内部就可能包含字节'\0'）。通过调用 *mysql_fetch_row()* 以获取行。
*	**MYSQL_FIELD**

	该结构包含关于字段的元数据，例如字段名，类型，字段大小。它的各个成员将在本节后面部分详细描述。重复调用 *mysql_fetch_field()* 以获取对应各个字段的 **MYSQL_FIELD** 结构。字段值不属于该结构，它们被包含于 **MYSQL_ROW** 结构。
*	**MYSQL_FIELD_OFFSET**

	该类型描述字段在字段列表的偏移量（被 *mysql_field_seek()* 使用），它是类型安全的（type-sage）。偏移指一行内字段的编号，从0开始计数。
*	**my_ulonglong**

	该类型用来表示行数，也用于函数 *mysql_affected_rows()* ， *mysql_num_rows()* 和 *mysql_insert_id()* 。该类型的取值范围为0-1.84e19。
	
	在某些系统上，可能无法直接打印 **my_ulonglong** 类型的值。这个时候，可以先将其转换成 *unsigned long* 类型，然后以 *%lu* 格式打印。例如：
	
	```c
	printf ("Number of rows: %lu\n",
        (unsigned long) mysql_num_rows(result));
	````
*	my_bool

	布尔类型，以表示true（非0）和false（0）。

下面描述 **MYSQL_FIELD** 结构的各个成员。此定义主要适用于 **SELECT** 类似语句返回的结果集各字段。在MySQL5.6，该结构也用来为由预处理 **CALL** 语句执行的存储过程所返回的 **IN** 和 **OUT** 参数提供元数据。在此情况下，该结构的某些成员会有跟作为字段值时不同的意义。

*	**char * name** 
	
	字段名，null结尾的字符串。如果 **AS** 子句为字段指定了别名，则其值就是那个别名。如果作为存储过程参数，其值是参数名。
* 	**char * org_name** 

	字段名，null结尾的字符串。跟字段别名无关。对于表达式，其值为空串。如果作为存储过程参数，其值为参数名。
*	**char * table** 
	
	如果字段不是计算出来的，该成员表示定义了此字段的表的名字。否则，该成员为空串。如果字段来自于视图，此成员表示视图的名字。如果表名或者视图名被 **AS** 从句指定了别名，则其值为该别名。如果结果集来自 **UNION** 运算，其值为空串。如果作为存储过程参数，其值为过程名。
*	**char * org_table** 
	
	表名，null结尾的字符串。跟表别名无关。如果字段来自于视图，此成员表示视图的名字。如果结果集来自 **UNION** 运算，其值为空串。如果作为存储过程参数，其值为过程名。
*	**char * db** 

	字段所在数据库的名字，null结尾字符串。如果该字段是计算出来的，其值为空串。如果结果集来自 **UNION** 运算，其值为空串。如果作为存储过程参数，其值为过程所在库的名字。
*	**char * catalog**

	目录名，值总为 “ *def* ”。
*	**char * def** 

	字段默认值，null结尾字符串。只有在调用 *mysql_list_fields()* 才会被设置。
*	**unsigned long length** 

	字段的长度。对应打印长度，以字节计算。
	
	该成员在结果集生成之前由server设置，所以在不事先知道字段确切值的情况下，它表示可装下字段最大可能值的所需的最小长度。
*	**unsigned long max_length** 

	结果集中字段的最大长度（字段长度的事实最大值，以字节计算）。如果是调用的 *mysql_store_result* 或者 *mysql_list_fields* ，表示的是字段的最大长度。但是如果调用的 *mysql_use_result* ，则其值为0。
	
	 *max_length* 是结果集中值的字符串表达形式的长度。例如，查询一个 **FLOAT** 字段，其最长的值为 **-12.345** ,  *max_length* 即为7（字符串' **-12.345** '的长度）。
	 
	 在预处理语句情况下， **max_length** 默认不赋值，因为对于二进制协议，字段值的长度取决于结果集中值的类型。（参考 [22.8.9，22.8.9，C API预处理语句数据结构]() 。）如果你一定需要这个值，通过 *mysql_stmt_attr_set()* 设置 **STMT_ATTR_UPDATE_MAX_LENGTH** 选项，这样在你调用 *mysql_stmt_store_result()* 时，该成员就会被复制了。（参考 [22.8.11.3， *mysql_stmt_attr_set()* ]() 和 [22.8.11.28， *mysql_stmt_store_result()* ]() 。）
*	**unsigned int name_length** 
	
	 *name* 成员的长度。
*	**unsigned int org_name_length** 
	
	 *org_name* 成员的长度。
*	**unsigned int table_length** 
	
	 *table* 成员的长度。
*	**unsigned int org_table_length** 
	
	 *org_table* 成员的长度。
*	**unsigned int db_length** 
	
	 *db* 成员的长度。
*	**unsigned int catalog_length** 
	
	 *cata_log* 成员的长度。
*	**unsigned int def_length** 
	
	 *def* 成员的长度。
*	**unsigned int flag**
	
	用来描述字段的比特标记位。 *flags* 的值通过设置下表所列的一个或者多个比特位获得。
<table>
	<tr><th>标记值</th><th>标记描述</th></tr>
	<tr><td> **NOT_NULL_FLAG** </td><td>字段不能为NULL</td></tr>
	<tr><td> **PRI_KEY_FLAG** </td><td>字段为主键的一部分L</td></tr>
	<tr><td> **UNIQUE_KEY_FLAG** </td><td>字段为唯一索引的一部分</td></tr>
	<tr><td> **MULTIPLE_KEY_FLAG** </td><td>字段为非唯一索引的一部分</td></tr>
	<tr><td> **UNSIGNED_FLAG** </td><td>字段有 **UNSIGNED** 属性</td></tr>
	<tr><td> **ZEROFILL_FLAG** </td><td>字段有 **ZEROFILL** 属性</td></tr>
	<tr><td> **BINARY_FLAG** </td><td>字段有 **BINARY** 属性</td></tr>
	<tr><td> **AUTO_INCREMENT_FLAG** </td><td>字段有 **AUTO_INCREMENT**　属性</td></tr>
	<tr><td> **ENUM_FLAG** </td><td>字段是 **ENUM** 类型</td></tr>
	<tr><td> **SET_FLAG** </td><td>字段是 **SET** 类型</td></tr>
	<tr><td> **BLOB_FLAG** </td><td>字段是 **BLOB** 或者 **TEXT** 类型（弃用）</td></tr>
	<tr><td> **TIMESTAMP_FLAG** </td><td>字段是 **TIMESTAMP** 类型（弃用）</td></tr>
	<tr><td> **NUM_FLAG** </td><td>字段是数值类型；下表更多信息</td></tr>
	<tr><td> **NO_DEFAULT_VALUE_FLAG** </td><td>字段没有默认值；下表更多信息</td></tr>
</table>
	这些标记中的有一些提示了字段的类型信息，它们或者被下文中要描述的 *field->type* 成员的 **MYSQL_TYPE_xxx** 系列取值所取代，或者与其联合使用：
	
	*	检查 *type* 值是否是 **MYSQL_TYPE_BLOB** 或者 **MYSQL_TYPE_TIMESTAMP** 以确认其是否是 **BLOB** 或者 **TIMESTAMP** 类型的值。（无需关心 **BLOB_FLAG** 和 **TIMESTAMP_FLAG** 标记。）
	
	*	**ENUM** 和 **SET** 类型值是以字符串形式返回。对于这两种情况，要确认 *type* 的值是 **MYSQL_TYPE_STRING** 并且 *flags* 设置了 **ENUM_FLAG** 和 **SET_FLAG** 标记位。

	**NUM_FLAG** 表示字段为数值类型，它涵盖以下 *type* 的取值： **MYSQL_TYPE_DECIMAL** ， **MYSQL_TYPE_NEWDECIMAL** ， **MYSQL_TYPE_TINY** ， **MYSQL_TYPE_SHORT** ， **MYSQL_TYPE_LONG** ， **MYSQL_TYPE_FLOAT** ， **MYSQL_TYPE_DOUBLE** ， **MYSQL_TYPE_NULL** ， **MYSQL_TYPE_LONGLONG** ， **MYSQL_TYPE_INT24** ， 和 **MYSQL_TYPE_YEAR** 。
	
	**NO_DEFAULT_VALUE_FLAG** 说明字段定义中没有 **DEFAULT** 子句。这一点对于 **NULL** 字段（有默认值 **NULL** ）和 **AUTO_INCREMENT** 字段（有隐含默认值）不成立。
	
	以下代码展示了对于 *flags* 值典型应用：
	
	```c
	if (field->flags & NOT_NULL_FLAG)
    	printf("Field can't be null\n");
	```
	
	可以使用下表所列的宏来判断 *flags* 的真假状态。
<table>
	<tr><th>标记状态</th><th>描述</th></tr>
	<tr><td> **IS_NOT_NULL(flags)** </td><td>字段定义为 **NOT NULL** 时为真</td></tr>
	<tr><td> **IS_PRI_KEY(flags)** </td><td>字段为主键时为真</td></tr>
	<tr><td> **IS_BOLB(flags)** </td><td>字段为 **BOLB** 类型或者 **TEXT** 类型时为真（已弃用；用检查 *field->type* 来代替）</td></tr>
</table>