## 22.8.7. C API函数描述
在本节中，参数或者返回值为NULL，是指其意义为C语言中的NULL，而不是MySQL中的NULL值。

有返回值的函数通常是返回一个指针类型值或者整型值。除非特别说明，返回值为指针类型的的函数如果返回了非NULL值则表示调用成功，返回NULL值表示失败，返回值为整型的函数返回0表示成功，返回非0表示失败。注意所谓非0就是指除0外的所有值，所以除非特别说明，不要以非0值来检查返回值。

```c
if (result)                   /* correct */
    ... error ...

if (result < 0)               /* incorrect */
    ... error ...

if (result == -1)             /* incorrect */
    ... error ...
```

当一个函数返回返回了错误，函数描述的错误子节会列出可能的错误类型。通过调用 *mysql_errno()* 来确定是哪一种错误。也可以调用 *mysql_error()* 来获取字符串形式的错误信息。

**22.8.7.1.**  *mysql_affected_rows()*

> *my_ulonglong mysql_affected_rows(MYSQL *mysql)*

**描述**

> *mysql_affected_rows()* 可以在调用 *mysql_query()* 或者 *mysql_real_query()* 执行一个语句之后立即被调用。如果上一个语句是 **UPDATE** ， **DELETE** 或者 **INSERT** ,该调用会返回相应的被修改，删除或者插入的行数。对于 **SELECT** 语句，该调用的作用跟 *mysql_num_rows()* 一样。
 
> 对于 **UPDATE** 语句，被影响行数默认是指事实被修改的行数。如果在以 *mysql_real_connect()* 调用连接 *mysqld* 时，如果设置了 **CLIENT_FOUND_ROWS** 标记，则被影响行数则是指“发现”的行数，也就是匹配 **WHERE** 从句的行数。
 
> 对于 **REPLACE** 语句，如果是一个新行替换了一条旧行，则受影响行数为2，因为在此情况下是先删除旧行再插入新行。
 
> 对于 **INSERT ... ON DUPLICATE KEY UPDATE** 语句，如果是插入了新行则受影响行数1，如果是更新已有行则受影响行数是2，如果对某行更新的目标值和当前值一样则受影响行数是0，但是如果此时设置了 **CLIENT_FOUND_ROWS** 标记，那么受影响行数这个值就为1了。
 
> 在使用 **CALLL** 语句调用了一个存储过程之后，该函数的返回值反映的是存储过程中最后一条语句的影响的行数，要是那条语句执行失败则其值为0。在存储过程内部，你可以调用SQL层面的 **ROW_COUNT()** 来获取每一单条语句的影响行数。
 
> 在MySQL 5.6中，该函数可以为更广泛的语句返回有意义的值。详细请参考 [12.14，信息函数]() 中对 **ROW_COUNT()** 的描述。
 
**返回值**

>大于0的整数则表示受影响或者返回的行数。0表示没有记录被修改，或者 **WHERE** 未被匹配或者根本没有执行任何查询。-1表示该函数出错了，或者是因为对于 **SELECT** 语句，在调用 *mysql_store_result()* 之前调用了 *mysql_affected_rows()* 。

> 因为 *mysql_affected_rows()* 返回是无符号整数，通过将返回值与 *(my_ulonglong)-1* 或者 *(my_ulonglong)~0* 比较来确定是否返回了-1。

**错误**

>无。

**范例**
```c
char *stmt = "UPDATE products SET cost=cost*1.25
              WHERE group=10";
mysql_query(&mysql,stmt);
printf("%ld products updated",
       (long) mysql_affected_rows(&mysql));
```

**22.8.7.2.**  *mysql_autocommit()*

> *my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)*

**描述**

> 如果mode参数是1则打开autocommit模式，如果mode参数是0则关闭该模式。

**返回值**

> 成功则返回0，发生错误时返回非0。

**错误**

> 无。

**22.8.7.3.**  *mysql_change_user()*

> *my_bool mysql_change_user(MYSQL *mysql, const char *user, const char, *password, const char *db)*

**描述**

> 改变 *mysql* 所代表连接上的用户，以及默认数据库。在后续的查询中，如果对表的引用没有指定数据库，则默认为 *db* 参数所指定的数据库。

> 如果当前连接用户无法认证或者没有访问新指定数据库的权限， *mysql_change_user()* 将会失败。在此情况下，当前连接上的用户和默认数据库都不会改变。

> 这个命令会重置状态，效果跟全新的连接一样。（参考 [22.8.16，控制自动重连行为]() ）它会回滚连接上所有的活跃事物，关闭以及丢弃所有的临时表，解锁所有被锁住的表。该会话系统变量全部被重置为相应的全局系统变量。预处理语句会被释放， **HANDLER** 变量会被关闭。以 **GET_LOCK()** 获取的锁也会被释放。哪怕用户没有更改，也会产生这些效果。

**返回值**

> 成功则返回0，发生错误时返回非0。

**错误**
> 错误信息跟 *mysql_real_connect()* 一样。

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
>  * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。
	
> * ER_UNKNOWN_COM_ERROR

> 	MySQL未实现该命令（可能因为版本较老）。
	
> * ER_ACCESS_DENIED_ERROR

> 	用户名或者密码错误。
	
> * ER_BAD_DB_ERROR
	
> 	数据库不存在。
	
> * ER_DBACCESS_DENIED_ERROR
	
> 	无访问该数据库的权限。
	
> * ER_WRONG_DB_NAME

> 	数据库名过长。
	
**范例**

```c
if (mysql_change_user(&mysql, "user", "password", "new_database"))
{
   fprintf(stderr, "Failed to change user.  Error: %s\n",
           mysql_error(&mysql));
}
```

**22.8.7.4.**  *mysql_character_set_name()*

> *const char *mysql_character_set_name(MYSQL *mysql)*

**描述**
> 返回当前连接上的默认字符集。

**返回值**

> 默认字符集名字

**错误**

> 无。

**22.8.7.5.**  *mysql_close()*

> *void mysql_close(MYSQL *mysql)*

**描述**

> 关闭连接。如果 *mysql* 指向的句柄是通过 *mysql_init()* 或者 *mysql_connect()* 自动分配的， *mysql_close()* 会释放掉该连接句柄。

**返回值**

无。

**错误**

无。

**22.8.7.6.**  *mysql_commit()*

> *my_bool mysql_commit(MYSQL *mysql)*

**描述**

> 提交当前事物。

> 这个函数的行为跟 *completion_type* 系统变量有关。尤其当该变量为 **RELEASE** （或者2）的时候，服务端在终止事物之后会执行释放并且关闭客户端连接。在客户端调用 *mysql_close()* 来从客户端关闭连接。

**22.8.7.7.**  *mysql_connect()*

> *MYSQL *mysql_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd)*

**描述**

> 该函数已被废弃。使用 *mysql_real_connect()* 代替。

> 该函数会尝试建立一条连接到 *host* 指定的主机上运行的的数据库引擎。在调用除了 *mysql_get_client_info()* 之外的所有API函数之前，必须确保先调用了该函数并且执行成功了。

> 各参数的意义跟 *mysql_real_connect()* 相同，除了connection可以为NULL。再次情况下，C API会为该结构自动分配内存，同时在 *mysql_close()* 被调用的时候将其释放。这一方式的一个缺点是如果连接失败，你无法获得错误信息。（如果要通过 *mysql_errno()* 或者 *mysql_error()* 来获取错误信息，必须提供一个有效的 **MYSQL** 指针。）

**返回值**

> 跟 *mysql_real_connect()* 一样

**错误**

> 跟 *mysql_real_connect()* 一样

**22.8.7.8.**  *mysql_create_db()*

> *int mysql_create_db(MYSQL *mysql, const char *db)*

**描述**

> 创建一个以 *db* 命名的数据库。

> 该函数已废弃。推荐使用 *mysql_query()* 执行 **CREATE DATABASE** 语句的方式。

**返回值**

> 当数据库创建成功时返回0。否则返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
>  * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。


**范例**

```c
if(mysql_create_db(&mysql, "my_database"))
{
   fprintf(stderr, "Failed to create new database.  Error: %s\n",
           mysql_error(&mysql));
}
```

**22.8.7.4.**  *mysql_data_seek()*

> *void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)*

**描述**

> 定位到查询结果集的任意行。 *offset* 参数表示行号。该值的范围应该位于0和 *mysql_num_rows(result)-1* 之间。

> 该函数要求结果集包含了整个查询结果，因此该函数只能与 *mysql_store_result()* 配合使用，不能跟 *mysql_use_result()* 一起使用。

**返回值**

> 无。

**错误**

> 无。

**22.8.7.10.**  *mysql_debug()*

> *void mysql_debug(const char *debug)*

**描述**

> 以给定字符串执行 **DBUG_PUSH** 。该函数使用了Fred Fish库。要使用这个函数，必须对客户端库正确编译以支持调试功能。参考 [23.4.3，调试包]()

**返回值**

> 无。

**错误**

> 无。

**范例**

> 以下示例会让客户端库在客户端机器上生成一个名为 */tmp/client.trace* 的trace文件。

```c
mysql_debug("d:t:O,/tmp/client.trace");
```

**22.8.7.11.**  *mysql_drop_db()*

> *int mysql_drop_db(MYSQL *mysql, const char *db)*

**描述**

> 删除以 *db* 命名的数据库。

> 该函数已废弃。推荐使用 *mysql_query()* 执行 **DROP DATABASE** 语句的方式。

**返回值**

> 当数据库删除成功时返回0。否则返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
>  * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**范例**

```c
￼if(mysql_drop_db(&mysql, "my_database"))
  fprintf(stderr, "Failed to drop the database: Error: %s\n",
          mysql_error(&mysql));
```

**22.8.7.12.**  *mysql_dump_debug_info()*

> *int mysql_dump_debug_info(MYSQL *mysql)*

**描述**

> 指示服务端将调试信息写入错误日志。连接上的用户必须具有 **SUPER** 权限。

**返回值**

> 命令执行成功时返回0。否则非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
>  * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.13.**  *mysql_eof()*

> *my_bool mysql_eof(MYSQL_RES *result)*

**描述**

> 该函数已废弃。使用 *mysql_errno()* 或者 *mysql_error()* 来代替。

> 该函数用来检查是否读到了结果集的最后一行。

> 当 *mysql_store_result()* 调用成功时，客户端一次性读取了整个结果集。 在此情况下， *mysql_fetch_row()* 返回NULL则说明结果集已经读取完毕，因此也就无需调用 *mysql_eof()*。当跟 *mysql_store_result()* 配合使用时， *mysql_eof()* 总是返回 true。

> 但是如果你调用了 *mysql_use_result()* 初始化结果集读取时，各行是通过重复调用  *mysql_fetch_row()* 一行一行地从服务端读取回来的。因为这一过程中数据库连接上可能会发生错误，所以 *mysql_fetch_row()* 调用返回NULL并不意味着到达了结果集尾部。此时你可以使用 *mysql_eof()* 来确定到底发生了什么，如果返回非0说明确实到达了结果集尾部，返回0说明有错误发送。

> 历史上，  *mysql_eof()* 比标准MySQL错误函数 *mysql_errno()* 和 *mysql_error()* 出现的早。因为错误函数提供了同样的信息，所以更推荐使用，而  *mysql_eof()* 则已被废弃。（事实上，错误函数提供了更多的信息，因为  *mysql_eof()* 仅仅返回一个boolean值，而错误函数则在错误发生时还会提示错误发生的原因。）

**返回值**

> 无错误发生时返回0。如果到达了结果集尾部则返回非0。

**错误**

> 无。

**范例**

> 以下范例演示了如何使用 *mysql_eof()* ：

```c
mysql_query(&mysql,"SELECT * FROM some_table");
result = mysql_use_result(&mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(!mysql_eof(result))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
}
```

> 使用MySQL标准错误函数可以达到同样的效果：

```c
mysql_query(&mysql,"SELECT * FROM some_table");
result = mysql_use_result(&mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(mysql_errno(&mysql))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
}
```

**22.8.7.14.**  *mysql_errno()*

> *unsigned int mysql_errno(MYSQL *mysql)*

**描述**

> 返回 *mysql* 所指定的连接上最后一次API调用的错误码，无论成功还是失败。如果没有错误发生，则返回0。客户端错误码定义在 *errmsg.h* 头文件中。服务端错误码定义在 *mysqld_error.h* 头文件中。 [附录C，错误，错误码以及一般性问题]() 也列出了这些信息。

> 要注意有些函数比如 *mysql_fetch_row()* 在执行成功时不会设置 *mysql_errno()* 的返回值。

> 一条规律是所有必须查询服务端以获取信息的函数都在成功的时候重置 *mysql_errno()* 的返回值。

>  *mysql_errno()* 返回的MySQL相关错误码跟 *mysql_sqlstate()* 返回的SQLSTATE值不是一回事。下面的例子说明了客户端展示错误信息的格式，1146是 *mysql_errno()* 的返回值而 **42S02** 则是相应的  *mysql_sqlstate()* 返回值：

```sql
shell> SELECT * FROM no_such_table;
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
```

**返回值**

上一次API调用如果失败，返回错误码。无错误发生时返回0。

**错误**

无。

**22.8.7.15.**  *mysql_error()*

> *const char *mysql_error(MYSQL *mysql)*

**描述**

> 