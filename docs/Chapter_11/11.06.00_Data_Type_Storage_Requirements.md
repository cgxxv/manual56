## 11.6 列类型存储需求

表数据在磁盘上的存储需求取决于几个因素。不同的存储引擎代表不同的列类型和存储原数据。表中的数据可能被压缩，无论是一列或整个行，表或列的存储需求的计算比较复杂。

尽管在磁盘上存储的位置不同，MySQL内部API进行通信和交换表行信息使用统一的数据结构，这适用于所有存储引擎。

一张表的内部表示的最大行大小是65,535字节，即使存储引擎能够支持较大的行。这个数字不包括BLOB和TEXT列，对于这个大小，它们只能提供9到12个字节。对于BLOB和TEXT数据，内部信息被存储在不同的大于行缓冲区的内存区。不同的存储引擎以不同的方式处理这些数据的分配和存储，根据它们所使用的处理相应类型的方法。更多信息，参见[14章，存储引擎][14.00.00]和[E.10.4节，“表中列数量和大小的限制”][E.10.04]。

### [InnoDB表](#11.06.01)

有关InnoDB表的存储需求参见[14.2.3.12.7，“物理行结构”][14.02.03.12.07]。

### [NDBCLUSTER表](#11.06.02)

> **重要**
> 
> NDB表使用4字节对齐；所有NDB数据存储是4字节的倍数。因此，一列值在NDB表中用15字节通常需要16字节。例如，在NDB表里，基于对齐原则TINYINT，SMALLINT，MEDIUMINT和INTEGER(INT)每条记录各需4字节存储。

> 每个BIT( *M* )列占 *M* 位存储空间。虽然个别BIT列不是4字节对齐，NDB每行的第1-32位所需的BIT列保留每行4字节（32位），另外4字节为33-64位，以此类推。

> 一个NULL本身不需要任何存储空间，如果表定义包含任何列定义为NULL，那么NDB每行保留4字节，可达32个空列。（如果一个MySQL Cluster表定义为超过32个空列达到64个空列，那么每行保留8字节。）

每个使用NDB存储引擎的表需要一个主键；如果你没有定义主键，NDB将创建一个“隐藏”主键。这个隐藏主键占用每行记录31-35字节。

你可以使用Perl脚本ndb_size.pl估算NDB存储需求。它连接当前的MySQL（非MySQL Cluster）数据库，并根据如果使用NDB存储引擎，生成一个数据库将需要多少空间的报告。更多信息，参见[17.4.24节，“ndb_size.pl—NDBCLUSTER大小需求估算”][17.04.24]。

### [数值类型存储需求](#11.06.03)

<table border="1" width='100%' cellspacing="0" cellpadding="0" bgcolor="write">
<tr>
<th align="left">列类型</th>
<th align="left">存储需求</th>
</tr>
<tr>
<td align="left">TINYINT</td>
<td align="left">1字节</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2字节</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3字节</td>
</tr>
<tr>
<td align="left">INT,INTEGER</td>
<td align="left">4字节</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8字节</td>
</tr>
<tr>
<td align="left">FLOAT( *p* )</td>
<td align="left">4字节 如果0 <= p<= 24，8字节 如果25 <= p<= 53 </td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4字节</td>
</tr>
<tr>
<td align="left">DOUBLE [PRECISION]，REAL</td>
<td align="left">8字节</td>
</tr>
<tr>
<td align="left">DECIMAL( *M* , *D* ),NUMERIC( *M* , *D* )</td>
<td align="left">变长；见下面讨论</td>
</tr>
<tr>
<td align="left">BIT( *M* )</td>
<td align="left">约 ( *M* +7)/8 字节</td>
</tr>
</table>

DECIMAL（和NUMERIC）列的值使用二进制格式表示，压缩九个十进制（基于10）位于4字节。对于每个值的整数和小数部分的存储将分别确定。每个九位数的倍数需要4字节，并且“剩余”数字需要4字节的一部分。剩余位数所需的存储根据以下表格给出：

<table border="1" width='100%' cellspacing="0" cellpadding="0" bgcolor="write">
<tr>
<th align="left">剩余的位数</th>
<th align="left">字节数</th>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">4</td>
</tr>
</table>

### [日期和时间类型存储需求](#11.06.04)

对于TIME，DATETIME和TIMESTAMP列，MySQL 5.6.4之前创建的表的存储需求不同于5.6.4以后的。这是因为5.6.4的改变，它允许这些类型具有小数部分，它们需要0-3个字节。

<table border="1" width='100%' cellspacing="0" cellpadding="0" bgcolor="write">
<tr>
<th align="left">列类型</th>
<th align="left">MySQL5.6.4前的存储需求</th>
<th align="left">MySQL5.6.4后的存储需求</th>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1字节</td>
<td align="left">1字节</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">3字节</td>
<td align="left">3字节</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3字节</td>
<td align="left">3字节+小数秒存储</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8字节</td>
<td align="left">5字节+小数秒存储</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4字节</td>
<td align="left">4字节+小数秒存储</td>
</tr>
</table>

从MySQL 5.6.4开始，对于YEAR和DATE的存储不变。但是，TIME，DATETIME和TIMESTAMP有不同的表示。DATETIME被更有效的压缩，对于无小数部分需要5而不是8字节，所有三个部分具有小数部分需要0-3个字节，取决于存储值的小数秒的精度。

<table border="1" width='100%' cellspacing="0" cellpadding="0" bgcolor="write">
<tr>
<th align="left">小数秒精度</th>
<th align="left">存储需求</th>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0字节</td>
</tr>
<tr>
<td align="left">1,2</td>
<td align="left">1字节</td>
</tr>
<tr>
<td align="left">3,4</td>
<td align="left">2字节</td>
</tr>
<tr>
<td align="left">5,6</td>
<td align="left">3字节</td>
</tr>
</table>

例如，TIME(0)，TIME(2)，TIME(4)和TIME(6)分别使用3,4,5和6个字节。TIME和TIME(0)是相等的并且存储需求也相同。

时间值的内部表示的详细信息，参见[MySQL内部：重要的算法和结构]()。

### [字符串类型存储需求](#11.06.05)

下面的表， *M* 表示声明的非二进制字符串类型列的字符长度和二进制字符串的字节。 *L* 表示给定的字符串值的实际长度，以字节为单位。

<table border="1" width='100%' cellspacing="0" cellpadding="0" bgcolor="write">
<tr>
<th align="left">列类型</th>
<th align="left">存储需求</th>
</tr>
<tr>
<td align="left">CHAR( *M* )</td>
<td align="left"> *M*  *  *w*  字节，0 <=  *M*  <=255， *w* 是字符集的最大长度字符所需的字节数</td>
</tr>
<tr>
<td align="left">BINARY( *M* )</td>
<td align="left"> *M* 字节，0 <=  *M*  <=255</td>
</tr>
<tr>
<td align="left">VARCHAR( *M* ),VARBINARY( *M* )</td>
<td align="left"> *L*  + 1字节 如果列值需要0-255字节， *L*  + 2字节 如果值需要更多超过255字节</td>
</tr>
<tr>
<td align="left">TINYBLOB,TINYTEXT</td>
<td align="left"> *L*  + 1字节，当 *L*  < 2<sup>8</sup></td>
</tr>
<tr>
<td align="left">BLOB,TEXT</td>
<td align="left"> *L*  + 2字节，当 *L*  < 2<sup>16</sup></td>
</tr>
<tr>
<td align="left">MEDIUMBLOB,MEDIUMTEXT</td>
<td align="left"> *L*  + 3字节，当 *L*  < 2<sup>24</sup></td>
</tr>
<tr>
<td align="left">LONGBLOB,LONGTEXT</td>
<td align="left"> *L*  + 4字节，当 *L*  < 2<sup>32</sup></td>
</tr>
<tr>
<td align="left">ENUM( *'value1','value2',...* )</td>
<td align="left">1或2字节，根据枚举值数目（最多65,535个值）</td>
</tr>
<tr>
<td align="left">SET( *'value1','value2',...* )</td>
<td align="left">1,2,3,4或8字节，根据set成员数目（最多64个成员）</td>
</tr>
</table>

哈哈哈

[14.00.00]: ../Chapter_14/14.00.00_Storage_Engines.md
[E.10.04]: ../Appendix_E/E.10.04_Limits_on_Table_Column_Count_and_Row_Size.md
[14.02.03.12.07]: ../Chapter_14/14.02.03_InnoDB_Concepts_and_Architecture.md#14.02.03.12.07
[17.04.24]: ../Chapter_17/17.04.24_ndb_size.pl_NDBCLUSTER_Size_Requirement_Estimator.md