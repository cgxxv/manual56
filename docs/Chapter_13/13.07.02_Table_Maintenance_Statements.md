### 13.7.2. 表维护语句

#### [13.7.2.1 ANALYZE TABLE语法](#13.7.2.1)

```sql
ANALYZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE
    tbl_name [, tbl_name] ...
```

ANALYZE TABLE为表分析和存储密钥分配。在分析过程中，表对于InnoDB和MyISAM读锁定。该语句适用于InnoDB，NDB和MyISAM表。对于MyISAM表，该语句相当于使用myisamchk --analyze。

关于在InnoDB内分析如何进行的更多信息，请参阅[Section 14.2.4.2.10, “Persistent Optimizer Statistics for InnoDB Tables”][14.02.04.02.10] 和[Section 14.2.7, “Limits on InnoDB Tables”][14.02.07] 。特别是，当启用innodb_stats_persistent[1782][] 项时，你必须在加载主要数据到InnoDB表，或创建一个新的索引后运行ANALYZE TABLE。
后。

MySQL使用存储的密钥分配来决定当你加入常数以外的其他值时应加入哪张表的顺序。此外，当在查询中决定哪些索引用于指定表中时，可以使用密钥分配。

这个语句需要给表授予SELECT [775][] 和INSERT [775][] 权限。

ANALYZE TABLE支持分区表，您可以使用ALTER TABLE...ANALYZE PARTITION来分析一个或多个分区；有关详细信息，请参阅[Section 13.1.7, “ALTERTABLE Syntax”][13.01.07] 和[Section 18.3.4, “Maintenance of Partitions”][18.03.04] 。

仅仅只在MySQL5.6.11中，必须在写下该语句前将gtid_next[2060][] 设置为AUTOMATIC。（错误＃16715809，错误＃16062608，错误＃69045）

ANALYZE TABLE返回的结果设置于以下列中.

<table summary="This table describes the columns of the
    ANALYZE TABLE result
    set." border="1"><colgroup><col><col></colgroup><thead>
<tr>
    <th scope="col">Column</th><th scope="col">Value</th>
</tr></thead><tbody>
<tr>
    <td scope="row"><code class="literal">Table</code></td><td>表名</td>
</tr>
<tr>
    <td scope="row"><code class="literal">Op</code></td><td>总是<code class="literal">analyze</code></td>
</tr>
<tr>
    <td scope="row"><code class="literal">Msg_type</code></td><td><code class="literal">status</code>, <code class="literal">error</code>,<code class="literal">info</code>, <code class="literal">note</code>或者<code class="literal">warning</code></td>
</tr>
<tr>
    <td scope="row"><code class="literal">Msg_text</code></td><td>信息报文</td>
</tr></tbody></table>

您可以使用[SHOW INDEX][] 查看存储的密钥分配。请参阅[Section 13.7.5.23,“SHOW INDEX Syntax”][13.07.05.23]。

如果表自最后一个ANALYZE TABLE语句都没有改变，则该表不会再次被分析。

默认情况下，服务器将ANALYZE TABLE语句写入二进制日志，让他们复制到复制从服务器。为了封锁记录，指定可选的NO_WRITE_TO_BINLOG关键字或其LOCAL别名。

#### [13.7.2.2 CHECK TABLE语法](#13.7.2.2)

```sql
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {FOR UPGRADE | QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
```

CHECK TABLE为一张表或多张表检查错误。CHECK TABLE适用于[InnoDB][14.02.00], [MyISAM][14.03.00] , [ARCHIVE][14.06.00] 以及 [CSV][14.05.00] 表。对于MyISAM表来说，关键数据也会被更新。

为了检查表，你必须对其拥有一些权限。

CHECK TABLE也能检查视图的问题，比如表涉及的视图定义不再存在。

CHECK TABLE支持分区表，您可以使用ALTER TABLE ... CHECK PARTITION来检查一个或多个分区；有关详细信息，请参阅[Section 13.1.7, “ALTER TABLE Syntax”][13.01.07] 和[Section 18.3.4, “Maintenance of Partitions”][18.03.04] 。

仅仅只在MySQL5.6.11中，必须在写下该语句前将gtid_next[2060][] 设置为AUTOMATIC。（错误＃16062608，错误＃16715809，错误＃69045）

#### 输出

CHECK TABLE返回的结果设置于以下列中.

<table summary="This table describes the columns of the
          CHECK TABLE result
          set." border="1"><colgroup><col><col></colgroup><thead>
<tr>
    <th scope="col">Column</th><th scope="col">Value</th>
</tr></thead><tbody>
<tr>
    <td scope="row"><code class="literal">Table</code></td><td>表名</td>
</tr>
<tr>
    <td scope="row"><code class="literal">Op</code></td><td>总是 <code class="literal">check</code></td>
</tr>
<tr>
    <td scope="row"><code class="literal">Msg_type</code></td><td><code class="literal">status</code>, <code class="literal">error</code>,
                <code class="literal">info</code>, <code class="literal">note</code>或者 <code class="literal">warning</code></td>
</tr>
<tr>
    <td scope="row"><code class="literal">Msg_text</code></td><td>信息报文</td>
</tr></tbody></table>

请注意，该语句会为每个检查表产生多行信息。最后一行具有一个Msg_type的status值且Msg_text通常为OK。如果你没有获得OK，或者Table is already up to date，您通常应该运行表的修复。请参阅[Section 7.6, “MyISAM Table Maintenance and Crash Recovery”][07.06.00]。Table is already up to date 表示表的存储引擎指出没有检查表的必要。

#### 检查版本兼容性

FOR UPGRADE项检查已命名表与MySQL的当前版本是否兼容。使用FOR UPGRADE，服务器检查每张表以确定从创建表开始，表的数据类型或索引中是否有任何不兼容的改变。如果没有则检查完成。否则，如果没有可能的不兼容项，服务器对表进行全面检查（这可能会花费一些时间）。如果全面检查完成，服务器使用当前MySQL版本号标记表的.frm 文件。标记.frm 文件能确有保相同服务器版本的表的深度检查会更快。

因为数据类型的存储格式或者排列的顺序发生了改变，就会发生不兼容的现象。我们的目的是避免这些改变，但在某些情况下，有可能改正问题将比版本之间的不兼容更差。

目前，FOR UPGRADE 发现了以下不兼容现象：

* 在MySQL4.1和5.0版本中InnoDB 和MyISAM 表的TEXT[] 列end-space的索引顺序发生了改变。
* 在MySQL5.0.3和5.0.5版本中DECIMAL[]数据类型的存储方式发生了改变。
* 如果表由不同于当前运行版本的MySQL服务器来创建的话，FOR UPGRADE提示表有一个不兼容版本的[.frmp][]文件。这种情况下，CHECK TABLE返回的结果集包含一行[Msg_type][]值为[error][]，[Msg_text][]值为[Table upgrade required. Please do "REPAIR TABLE
`tbl_name`" to fix it!][]。
* 在MySQL5.6.5中[YEAR(2)](#The_YEAR_Type)被弃用了。CHECK TABLE[]推荐使用REPAIR TABLE[]来处理这种数据类型的表。用REPAIR TABLE[]转换[YEAR(2)](#The_YEAR_Type) 为 [YEAR(4)](#The_YEAR_Type)。

#### [检查数据一致性](#Checking_Data_Consistency)
下表列出了其它可用的检查选项。这些选项传递到存储引擎，存储引擎不一定会使用这些选项。

<table summary="This table describes other CHECK TABLE options." border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Type</th><th scope="col">Meaning</th></tr></thead><tbody>

<tr>
<td scope="row">
    <code class="literal">QUICK</code></td><td>不扫描每一行来检查不正确的链接。应用到
    <code class="literal">InnoDB</code> 和 <code class="literal">MyISAM</code>
    表和视图中。
</td>
</tr>
<tr>
<td scope="row"><code class="literal">FAST</code></td><td>只检查没有被正确关闭的表。应用于
                <code class="literal">MyISAM</code> 表和视图；
                <code class="literal">InnoDB</code>会忽略掉</td>
</tr><tr><td scope="row"><code class="literal">CHANGED</code></td><td>只有在上一次检查以后有修改或者没有被正确关闭时才会进行检查。应用于
                <code class="literal">MyISAM</code> 表和视图；
                <code class="literal">InnoDB</code>会忽略掉。</td>
</tr><tr><td scope="row"><code class="literal">MEDIUM</code></td><td>扫描每一行验证已删除的连接是合法的。并且计算每一行的校验和，和之前已经计算好的校验和进行验证。应用于
                <code class="literal">MyISAM</code> 表和视图；
                <code class="literal">InnoDB</code>会忽略掉。</td>
</tr><tr><td scope="row"><code class="literal">EXTENDED</code></td><td>对每一行的所有key做一个完整的检查。确保表是100%一致的，但是会花费比较长的时间。应用于
                <code class="literal">MyISAM</code> 表和视图；
                <code class="literal">InnoDB</code>会忽略掉。</td>
</tr>
</tbody></table>


如果QUICK, MEDIUM 或者 EXENDED都没有指明，MyISAM表默认的动态格式是MEDIUM。这在运行[myisamchk --medium-check
tbl_name][04.06.03]时有同样的结果。除非CHANGED 或者 FAST被指定了，否则静态格式的MyISAM表的默认检查类型也是MEDIUM。在那种情况下，默认值是QUICK。由于在CHANGED 和 FAST的时候行很少出现问题，所以行扫描也就略过了。

你可以合并检查选项，比如在下面的例子中，做一个表的快速检查以确认是否表被正确关闭了：

```sql
CHECK TABLE test_table FAST QUICK;
```

> ** Note **
> 
> 有些情况下，CHECK TABLE会改变表。这发生在表被标记为“corrupted” 或者 “not closed properly”，但CHECK TABLE 并没有找到表中有任何问题的时候。这种情况下，CHECK TABLE 把表标记为正常的。

如果表损坏了，这最有可能的问题是在索引中而不是数据部分。所有预先检查类型完整地检查所有并且会找到最多的错误。

如果你想要检查一个你假设是正常的表，你不应该使用任何检查选项，或者只使用QUICK选项。这个选项在当你比较急或者可以承受非常小的QUICK无法在数据文件中找到错误的风险时使用。（在大多数情况下，正常使用的情况，MySQL应该找到数据文件中的任何错误。如果这种情况发生的话，表会被标记为"corrupted"，并且在修复前都不能使用。）

如果你想要经常检查表，FAST 和CHANGED总是被用于脚本中（比如，在cron中执行）。大多数情况下，FAST比CHANGED更好。（唯一的情况是，当你怀疑你已经在MyISAM代码中发现了一个bug。）

EXTENDED只有在MySQL尝试更新一行或者通过关键字找到一行而你已经运行了一个普通的检查但仍然有奇怪的错误的时候才被使用。如果一个正常的检查成功了以后，这种情况不太可能发生。

使用[CHECK TABLE ... EXTENDED](#13.7.2.2_CHECK_TABLE_Syntax)可能影响由优化器生成的执行计划。

一些由CHECK TABLE报告的问题不能被正确修复：
* Found row where the auto_increment column has the value 0.

这意味着有一行数据在AUTO_INCREMENT索引列包含0值。（通过UPDATE语句设置列为0而创建一行AUTO_INCREMENT值为0的行是可能的。）

这本身不是错误，但是如果你决定到处表并且存储它或者在表上做ALTER TABLE操作时会导致问题。在这种情况下，AUTO\_INCREMENT列通过AUTO\_INCREMENT列的规则在比如重复键这些可能导致问题的地方改变取值。

为避免警告，简单的执行UPDATE语句来设置列的值大于0。




####InnoDB 表
以下注意点适用于InnoDB表：
* 如果CHECK TABLE找到InnoDB表的问题，服务器可能会关闭以防止错误扩大。错误的细节会被写入错误日志。
* 如果CHECK TABLE遇到InnoDB表或索引的损坏或者错误，它报告一个错误。它不会关闭服务。MySQL5.5启动时，CHECK TABLE在表出错时经常标记索引，并且有时候标记表来防止更多的对表和索引的使用。
* 如果CHECK TABLE在第二所有找到错误的序号，他会报告错误，但不会关闭服务或者禁止访问文件。
* CHECK TABLE审查索引页结构，然后审查每一个键。它不会验证指向集群记录的键指针或者寻找BLOB指针的路径。
* 当InnoDB表在file-per-table模式下存在它自己的.ibd文件中, .ibd文件的前三页包含头部信息而不是表或者索引数据。CHECK TABLE语句不检查只影响头部数据的错误。使用innochecksum命令来检查整个InnoDB .ibd文件的内容。
* 在巨大的InnoDB表上运行CHECK TABLE时，其它的线程可能会在CHECK TABLE执行时被锁住。为避免超时，CHECK TABLE操作的信号等待极限（600秒）被扩展到2小时（7200秒）。如果InnoDB检测到信号等待时间大于等于240秒时它开始把InnoDB监控输出到错误日志。如果一个锁要求扩展信号等待限制，InnoDB会忽略此进程。为避免可能的标记等待时间超时，你可以运行CHECK TABLE QUICK来代替CHECK TABLE。




#### [13.7.2.3 CHECKSUM TABLE语法](#13.7.2.3)
```sql
CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]
```

CHECKSUM TABLE根据表的内容报告校验和。你能使用这个语句来验证备份，回滚，或其它会把数据恢复到已知状态的之前和之后的内容。这个语句需要表的[SELEC\[777\]](#SELECT)权限。


#### 性能的考虑

默认情况下，整个表是一行一行被读取然后计算校验和。对于大表，这会花费很长的时间，因此你只能偶尔地进行这种操作。这种一行一行的计算是在除MyISAM外InnoDB和其它所有存储引擎和未使用CHECKSUM=1子句创建的MyISAM表中通过EXTENDED子句获取的。

对于使用CHECKSUM=1子句创建的MyISAM表，CHECKSUM TABLE 或者 CHECKSUM TABLE ... QUICK 非常快速地返回“实时”校验和。如果表没有任何这些条件，QUICK方法返回NULL。关于CHECKSUM子句语法请参考[Section 13.1.17, “CREATE TABLE Syntax”][13.01.17]。

对于一张不存在的表，CHECKSUM TABLE返回NULL，并且生成一个警告。

MySQL5.6.4 之前的版本中，除非使用EXTENDED选项，否则分区表使用CHECKSUM TABLE时返回0。（Bug #11933226, Bug #60681）

校验值取决于表的行格式。如果行格式改变了，校验和也会改变。例如，从MySQL4.1到5.0，VARCHAR的存储格式发生了改变，所以如果一张4.1的表升级到5.0的版本，校验和会改变。

> **Important**
> 
> 如果



//注释：链接

[04.04.07]: ./Chapter_04/04.04.07_mysql_upgrade_Check_and_Upgrade_MySQL_Tables.md
[04.06.03]: ./Chapter_04/04.06.03_myisamchk_MyISAM_Table-Maintenance_Utility.md
[05:00:00]: ./Chapter_05/05.00.00_MySQL_Server_Administration.md
[05.01.07]: ./Chapter_05/05.01.07_Server_SQL_Modes.md
[06.01.02]: ./Chapter_06/06.01.02_Keeping_Passwords_Secure.md
[06.02.00]: ./Chapter_06/06.02.00_The_MySQL_Access_Privilege_System.md
[06.02.01]: ./Chapter_06/06.02.01_Privileges_Provided_by_MySQL.md
[06.02.03]: ./Chapter_06/06.02.03_Specifying_Account_Names.md
[06.02.04]: ./Chapter_06/06.02.04_Access_Control_Stage_1_Connection_Verification.md
[06.02.05]: ./Chapter_06/06.02.05_Access_Control_Stage_2_Request_Verification.md
[06.03.04]: ./Chapter_06/06.03.04_Setting_Account_Resource_Limits.md
[06.03.05]: ./Chapter_06/06.03.05_Assigning_Account_Passwords.md
[06.03.07]: ./Chapter_06/06.03.07_Pluggable_Authentication.md
[06.03.09]: ./Chapter_06/06.03.09_Using_SSL_for_Secure_Connections.md
[11.05.00]: ./Chapter_11/11.05.00_Data_Type_Default_Values.md
[13.01.17]：./Chapter_13/13.01.17_CREATE_TABLE_Syntax.md
[19.06.00]: ./Chapter_19/19.06.00_Access_Control_for_Stored_Programs_and_Views.md
[05.01.04]: ./Chapter_05/05.01.04.00_Server_System_Variables.md
[14.02.04.02.10]: ./Chapter_14/14.02.04.02.10_Persistent_Optimizer_Statistics_for_InnoDB_Tables.md#14.2.4.2.10
[14.02.07]: ./Chapter_14/14.02.07_Limits_on_InnoDB_Tables.md
[13.01.07]: ./Chapter_13/13.01.07_ALTERTABLE_Syntax.md
[18.03.04]: ./Chapter_18/18.03.04_Maintenance_of_Partitions.md
[13.07.05.23]: ./Chapter_13/13.07.05.23_SHOW_INDEX_Syntax.md#13.7.5.23
[14.02.00]: ./Chapter_14/14.02.00_The_InnoDB_Storage_Engine.md
[14.03.00]: ./Chapter_14/14.03.00_The_MyISAM_Storage_Engine.md
[14.06.00]: ./Chapter_14/14.06.00_The_ARCHIVE_Storage_Engine.md
[14.05.00]: ./Chapter_14/14.05.00_The_CSV_Storage_Engine.md
[07.06.00]: ./Chapter_07/07.06.00_MyISAM_Table_Maintenance_and_Crash_Recovery.md
[13.07.01.07]: ./Chapter_13/13.07.01.07_SET_PASSWORD_Syntax.md
