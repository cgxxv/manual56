
## 5.3 磁盘I/O和INNODB表文件空间管理
### [5.3.1 Innodb 磁盘I/O] [1]
### [5.3.2 文件空间管理] [2]
### [5.3.3 Innodb 检查点] [3]
### [5.3.4 表磁盘空间碎片整理] [4]



作为DBA，你必须关注和管理磁盘I/O以防止I/O子系统负载达到饱和和存储设备空间不足。（ACID）设计模式为了保证数据的可靠性，对磁盘I/O增加了额外的开销。Innodb 通过优化数据库的工作模式和磁盘文件的组织方式来尽量减少磁盘I/O调度。I/O的调用有时会被推迟进行，直到整个数据库系统负载较低或者为了保证数据一致性：如（快速关闭）后数据库重启时就需要调用大量I/O（redo log）。

本节讨论作为MySQL默认存储引擎的innodb在管理I/O和磁盘空间时的注意事项：

* 控制后台I/O的使用数量以提升查询性能

* 打开/关闭那些通过消耗更多I/O操作来提供额外持久性的功能项

* 以很多小文件或者较少大文件的方式组织表
* 适当设置redo 日志的文件大小，防止redo日志写满时造成I/O压力。
* 如何通过整理表空间来优化查询性能

###5.3.1 InnoDB 磁盘I/O
 InnoDB 通过创建若干个线程来管理I/O操作，尽可能地使用异步磁盘I/O调度，当数据库的其他操作需要优先使用I/O时，这些线程用于调度进行中的操作。在Linux和Windows平台，InnoDB使用操作系统和函数库来进行“本地” 异步I/O调度。在其他平台，InnoDB任然使用I/O线程，而且这些线程事实上会等待当前I/O请求完成；这中技术被称为‘伪’异步I/O。
 
Read-Ahead（预读）
如果InnoDB可确定数据有很高的可能性被马上使用，这时，InnoDB会使用预读方式将这些数据读取到内存主缓存中。对磁盘上连续数据进行少量较大的读请求比进行大量较小的分散的请求效率会更高，在InnoDB中，有2种预读方式：
*顺序预读，如果InnoDB发现以连续模式读取表空间的一个片段，它将向I/O系统发起后续一批数据的读取。
*随机模式，如果InnoDB发现表空间中一部分正在完整地读取到主缓存中，它将发起剩下数据的读取

Doublewrite Buffer（两次写缓存）
InnoDB使用一个包含两次写缓存的磁盘刷新机制。这种方式增加了在系统崩溃或者宕机后数据恢复的安全性，对大多数Unix系统减少了对fsync（）操作的的调用从而得到性能提升。

在数据刷新到磁盘的过程中，在将数据页写入数据文件中之前，InoDB先把数据页写入到一段连续的表空间中（doublewrite buffer）。只有在两次写缓存被写入并刷新到缓存后InnoDB才将数据页写到数据文件中特定位置。如果系统在数据页写入过程中崩溃（产生断裂的数据页），InnoDB在恢复过程中可以从两次写缓存中找到一份完整的副本来完成数据恢复。


###5.3.2 文件空间管理
  配置文件中配置的数据文件组成了InnoDB系统表空间（元数据，undo日志等），各个数据文件串联在一起形成整个表空间，逻辑上是一个整体，在使用中不会拆开。目前不能指定表在整体表空间的分配位置。对于一个新建的表空间，InnoDB从第一个数据文件开始分配空间。

  通过开启参数innodb_file_per_table，之后新建的表会单独创建相应的以.idb为后缀的表空间文件，这样可以避免由于所有表和索引都存储在系统表空间种带来的一些问题。对于独立表空间，在磁盘文件中的碎片会更少，表数据被清空时，磁盘空间将回收，使用共享表空间时空间不会回收。


数据页，区，段，表空间
表空间由数据页组成，在MySQL实例中，所有的表空间的数据页大小一样，默认情况下，所有的表空间中的数据页大小为16KB，在创建实例时，通过参数 innodb_page_size可以减少数据页大小为8KB/4KB.
区由成组的数据页构成（64个连续的16KB大小数据页，128个8KB大小数据页，256个4KB大小数据页），大小为1MB。每一组在InnoDB表空间中称为段（这里端和回滚段含义不同，回滚段中包含多个数据页段）。
当一个段在表空间逐渐增加，InnoDB一次分配表空间中最首32个数据页。之后，InnodB开始分配整个区到这个段中，InnoDB为保证数据的有序性一次性可增加4个区到一个较大的段中
	InnoDB中有2个段被分配给每一个索引，一个是用于存储非叶节点，另一个用于存储叶节点。叶节点中包含具体的表数据，因此，将叶节点在磁盘中顺序存储有助于提升顺序I/O操作的性能
	表空间有一部分页存储其他叶的位图信息，一些区在存储时无法放到一个段中，但只能作为独立叶。？
	表中数据被删除时，InnoDB回收相应的B-tree 索引。释放的空闲空间时候能被其他用户使用取决于删除操作释放的是单独的叶或者区。删除表或者删除表所有数据操作将释放空间供其他用户使用。但是删除记录只会在purge操作时发生物理删除，purge会在数据不会在用于事务回滚或一致性读的情况下自动发起。（参考 Section 14.2.3.11, “InnoDB Multi-Versioning”）
	通过表空间监控器可以获取更多的信息： Section 14.2.4.4, “SHOW ENGINE INNODB STATUS and the InnoDB Monitors”.


数据页和数据行对应关系
除了不定长列属性（varbinary，varchar，blob和text），每行最大长度略小于数据页的一半大小。也就是说每行最大长度为8000字节，LONGBLOB和LONGTEXT列必须小于4GB，整行数据包含BLOG和TEXT列大小必须小于4GB。
如果一行数据小于半个数据页长度，它将存储在一个数据页内。如果超过半页长度，不定长列将被选择存储到外部数据页直到行数据长度小于半页长度。对于外部页存储的列，InnoDB将其前768字节和其他列一起存放，其余部分存储在外部页中。每一个使用外部存储的页拥有其溢出页列表信息。在长为768字节的前缀之后的是长为20字节用于存储这一列实际长度和指向对应的存储剩余全部数据的溢出页列表。

###5.3.3 InnoDB 检查点
日志文件越大，在检查期间磁盘I/O就越少。一般建议将日志文件的大小设置为和主缓存一样甚至更大。在之前的版本中，较大的日志文件会造成恢复过程需要消耗很长时间。从MySQL5.5开始，崩溃恢复功能的增强将支持大容量的日志文件也可以快速地进行恢复。（严格地讲，此项改进在携带InnodB Plugin 1.0.7 的MySQL 5.1和之后版本就已经支持，这里说MySQL5.5版本是因为InnoDB作为默认存储引擎）

检查点工作原理
InnodB使用称为fuzzy checkpointing的方式进行检查点。InnodB以小批次的方式将数据脏页从缓存中刷新到磁盘中。没有必要将缓存数据一次性刷新到磁盘中，并且这样做也会导致在检查过程中中断用户的SQL执行过程。
在崩溃恢复过程中，InnoDB寻找日志文件中的检查点标签，在这个标签之前的数据已经成功刷新到磁盘数据文件中（刷新原理）。因此，InnodB从这个标签开始扫描日志文件内容，并将redo日志文件中的事务重新应用。


###5.3.4 表磁盘空间整理

随机插入或者从辅助索引删除数据都可以导致索引出息间隙，间隙的意思是索引数据在磁盘上的物理位置顺序和数据行在数据页上的索引顺序不再邻近，或者分配给索引的64-page中存在很多未使用的数据页。

间隙的一个现象就是一个表占用了比它应该占用的更多的空间。具体应该多少很难衡量。InnodB的数据和索引都以B-bree组织，他们的填充因数fill factor 变化范围为50%到100%。另一个间隙现象就是表扫描需要比它应该需要的更多的时间：

```sql
SELECT COUNT(*) FROM t WHERE non_indexed_column <> 12345;
```

上面的查询请求MySQL进行全表扫描，也是大表最慢的查询方式。
为了增加索引扫描效率，你可以提交一个空操作来使MySQL重建这个表：

```sql
ALTER TABLE tbl_name ENGINE=INNODB
```

解决间隙的另一个办法是使用mysqldump将数据导出，然后删除数据表，再将数据导入到新表中。
如果查询方式总是为升序或者数据只会从最后删除，InnodB文件空间管理算法可以确保索引间隙不会产生。	

[1]:http://www.baidu.com "title 5.3.1"
[2]:http://www.baidu.com "title 5.3.2"
[3]:http://www.baidu.com "title 5.3.3"
[4]:http://www.baidu.com "title 5.3.4"



<!--xchliu-->
<!--2013_09_07-->

























