### 5.1.6 服务器状态变量

服务器维护很多提供自身运行信息的状态变量。你可以使用`SHOW [GLOBAL | SESSION ] STATUS`语句（参考[每13.7.5.36小节，SHOW STATUS语法][SHOW_STATUS]）来查看这些变量和它们的值。选项`GLOBAL`关键词汇总了所有连接的值，而`SESSION`显示当前连接的值。

    mysql> SHOW GLOBAL STATUS;
    +-----------------------------------+------------+
    | Variable_name                     | Value      |
    +-----------------------------------+------------+
    | Aborted_clients                   | 0          |
    | Aborted_connects                  | 0          |
    | Bytes_received                    | 155372598  |
    | Bytes_sent                        | 1176560426 |
    ...
    | Connections                       | 30023      |
    | Created_tmp_disk_tables           | 0          |
    | Created_tmp_files                 | 3          |
    | Created_tmp_tables                | 2          |
    ...
    | Threads_created                   | 217        |
    | Threads_running                   | 88         |
    | Uptime                            | 1389872    |
    +-----------------------------------+------------+

很多变量会被[FLUSH STATUS][FLUSH_STATUS]重置为0。

[SHOW_STATUS]: http://dev.mysql.com/doc/refman/5.6/en/show-status.html
[FLUSH_STATUS]: http://dev.mysql.com/doc/refman/5.6/en/flush.html

下表列出所有可用的服务器状态变量：

表5.5 系统变量概要

    这儿有一张超级大表

[mysql_clasuster]: http://dev.mysql.com/doc/refman/5.6/en/mysql-cluster-status-variables.html
[Connection_errors__xxx_]: http://dev.mysql.com/doc/refman/5.6/en/server-status-variables×.html#statvar_Connection_errors_xxx
[host_cache]: http://dev.mysql.com/doc/refman/5.6/en/host-cache-table.html
[binlog_cache_size]: http://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#sysvar_binlog_cache_size
[Binlog_stmt_cache_disk_use]: http://dev.mysql.com/doc/refman/5.6/en/server-status-variables.html#statvar_Binlog_stmt_cache_disk_use
[delete]: http://dev.mysql.com/doc/refman/5.6/en/delete.html
[update]: http://dev.mysql.com/doc/refman/5.6/en/update.html
[statvar_Qcache_hits]: http://dev.mysql.com/doc/refman/5.6/en/server-status-variables.html#statvar_Qcache_hits
[query-cache-status-and-maintenance]: http://dev.mysql.com/doc/refman/5.6/en/query-cache-status-and-maintenance.html
[buffer_pool]: .
[pages]: .
[row_lock]: .

系统变量有如下含义。有关MySQL Cluster的状态变量含义，参考[第17.3.4.4小节，MySQL Cluster系统变量](mysql_cluster)。

* Abouted_clients  
因客户端没有正常关闭的而中止的死连接的数目。见[第5.2.11节，](5.2.11，通信错误与中止连接)。
[5.2.11]: http://dev.mysql.com/doc/refman/5.6/en/communication-errors.html

* Aborted_connects  
尝试连结MySQL服务器的失败的次数。见[第5.2.11节，](5.2.11，通信错误与中止连接)。  
如需连接相关信息，检查[Connection_errors__xxx_](Connection_errors__xxx_)状态变量和[host_cache](host_cache)表。

* Binlog_cache_disk_use  
使用临时二进制日志缓存（temprorary binary log cache）但超过了[biglog_cache_size](binlog_cache_size)所以使用了临时文件存储语句的事务数。  
引起二进制日志缓存写入到硬盘的非事务语句数量在状态变量[Binlog_stmt_cache_disk_use](Binlog_stmt_cache_disk_use)中单独跟踪。

* Binlog_cache_use  
使用二进制日志缓存的事务数目。

* Binlog_stmt_cache_disk_use  
使用二进制日志语句缓存（binary log statement cache）但超过了[binlog_stmt_cache_size](binlog_stmt_cache_size)所以使用了临时文件存储语句的非事务数语句数目。
[binlog_stmt_cache_size]: http://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#sysvar_binlog_stmt_cache_size

* Binlog_stmt_cache_use  
使用了二进制日志语句缓存的非事务语句数目。

* Bytes_received  
从所有客户端接收的字节数。

* Bytes_sent  
发送给所有客户端的字节数。

* Com\__xxx_    
`Com_xxx`语句计数器表示___xxx___语句被执行的次数。每一种语句类型都有一个对应的状态变量。例如，`Com_delete`和`Com_update`统计[DELETE](delete)和[UPDATE](update)语句，相应的，`Com_delete_multi`和`Com_update_multi`是类似的，但是统计使用了多表的[DELETE](delete)和[UPDATE](update)的语句。  
如果一个查询的结果是从查询缓存中返回的，服务器会增加[Qcache_hits](statvar_Qcache_hits)的状态变量，而不会加`Com_select`。参考[8.9.3.4节，查询缓存的状态与维护](query-cache-status-and-maintenance)。  
即使在预编译参数未知或执行过程中有错误发生，所有`Com_stmt__xxx_`的变量都会增加。也就是说，这些值对应的是发出的请求的数目，而不是请求成功完成的数目。  
`Com_stmt_xxx`状态变量如下：
    * Com_stmt_prepare
    * Com_stmt_execute
    * Com_stmt_fetch
    * Com_stmt_send_long_data
    * Com_stmt_reset
    * Com_stmt_close  
    
  这些变量表示预编译语句命令。他们的名字指的是在网络层使用的`Com_xxx`的命令集。也就是说，他们的值在调用以及执行诸如**mysql_stmt_prepared**, **mysql_stmt_execute()**的预编译语句API时增加。然而，`Com_stmt_prepared`、`Com_stmt_execute`和`Com_stmt_close`也会分别因[PREPARE]、[EXECUTE]和[DEALLOCATE PREPARE]而增加。另外，老版本的语句计数器变量`Com_prepare_sql`、`Com_execute_sql`和`Com_dealloc_sql`的值也会因[PREPARE]、[EXECUTE]和[DEALLOCATE PREPARE]而增加。`Com_stmt_fetch`代表从游标中获取数据时的网络往返总数。  
  `Com_stat_reprepare`指的是表或视图的元数据发生变化后服务器对使用了它们的语句自动重新预编译的次数。一个重新预编译操作会增加`Com_stmt_reprepare`和`Com_stmt_prepard`。

* Compression  
是否在客户端/服务器协议中使用了压缩。

* Connection_error_xxx  
这些变量提供了在客户端连接过程中发生错误的信息。它们是仅全局所有且代表所有主机连接错误的总和。这些变量跟踪错误并不占用主机缓存（参考第8.11.5.2，DNS查询优化和主机缓存），比如不相关联的TCP连接，在很早期的连结中发生（甚至早到连IP都不确认），或没有指定任何具体IP地址（如内存不足的情况）。这些变量是在MySQL 5.6.5中加入的。
    * Connection_error_accept  
    在侦听端口上调用`accept()`时发生的错误数。
    * Connection_error_internal  
    因服务器内部错误引起的拒绝连接数，比如启动一个新线程失败或内存不足的情况。
    * Connection_error_max_connections  
    因服务器[max_connections]上限到达而引起的拒绝连接数。
    * Connection_error_peer_addr  
    在搜索正在连结的客户端的IP地址时发生错误的数目。
    * Connection_errors_select  
    在侦听端口上调用`select()`或`poll()`时发生错误的数目。（这个操作的失败并不一定意味客户端连接被拒绝。）
    * Connection_errors_tcpwrap  
    被`libwrap`包拒绝的连接的数目。
    
* Connections  
尝试连接（成功或失败）MySQL服务器的连接数。

* Created_tmp_disk_tables  
在执行语句时由服务器创建的内部硬盘临时表的数目。  
如果一个内部临时表在刚开始时是以内存表创建的，但后来变得太大了，MySQL会自动转为硬盘表。内存临时表大小的上限是[tmp_table_size]和[max_heap_table_size]两者中的小者。如果[Created_tmp_disk_table]值很大，你可以增大[tmp_table_size]或[max_heap_table_size]的值来减少内存中的内部临时表被转化为硬盘表的可能性。  
你可以通过比较[Created_tmp_disk_tables]和[Create_tmp_tables]变量的值来比较创建的内部硬盘临时表的数目和创建临时表的总数。  
也可以参考[第8.4.3.3节，MySQL如何使用内部临时表]。

* Created_tmp_files  
[mysqld]创建的临时文件数。

* Created_tmp_tables  
在执行语句时由服务器创建的内部临时表的数目。  
你可以通过比较[Created_tmp_disk_tables]和[Create_tmp_tables]变量的值来比较创建的内部硬盘临时表的数目和创建临时表的总数。  
也可以参考[第8.4.3.3节，MySQL如何使用内部临时表]。  
每次执行[SHOW STATUS]都会使用一个内部临时表，并增加全局的[Created_tmp_tables]的变量值。

* Delayed_errors  
在使用[INSERT DELAYED]写入时因某些错误发生造成而写入的行数（可能是`duplicate key`）。  
在MySQL 5.6.7中，这个状态变量是过期的（因为DELAYED插入已废弃），并且在将来的版本中会被移除。

* Delayed_insert_threads  
非事务表使用的[INSERT DELAYED]处理线程数。  
在MySQL 5.6.7中，这个状态变量是过期的（因为DELAYED插入已废弃），并且在将来的版本中会被移除。

* Delayed_writes  
使用[INSERT DELAYED]写入到非事务表中的数据行数。  
在MySQL 5.6.7中，这个状态变量是过期的（因为DELAYED插入已废弃），并且在将来的版本中会被移除。

* Flush_commands  
服务器刷表的次数，不管是因为用户执行了[FLUSH TABLES]语句还是因为服务器内部裙定期操作。在收到`COM_REFRESH`包时这个值也会增加。这与[Com_flush]有区别，[Com_flush]指的是多少个`FLUSH`语句被执行了，无论是[FLUSH TABLES]、[FLUSH LOGS]还是其它等等。

* Handler_commit  
内部[COMMIT]语句数目。

* Handler_delete  
从表里删除行的次数。

* Handler_external_lock  
服务器什会每次调用exteral_lock()时增加这个变量，常发生在访问一个表实例的开始和结束。这可能在不同的存储引擎之间有一些不同。例如，这个变量可以用在提示一个语句访问一张分区表时，在锁发生时有多少个分区被剪掉：检查计数器因这个语句增加了多少，减去2（表本身两次调用），然后再除以2就得到被锁住的分区数。这个变量在MySQL 5.6.2中加入。

* Handler_mrr_init  
服务器使用存储引擎自己实现的访问表的多路读（Multi-Range Read）的次数。

* Handler_prepare  
两段式提交操作中预编译段的计数器。

* Handler_read_first  
索引中第一个条目被读取的数目。如果这个值很高，表明服务器做了很多全索引扫描；如`SELECT col1 FROM foo`，假设`col1`是有索引的。

* Handler_read_key  
基于一个有索引的列来读取行的请求数。如果这个值很高，这是一个很好的迹象，你的表针对查询的索引非常好。

* Handler_read_last  
读一个索引最后一个键值的请求数。在有`ORDER BY`的情况下，服务器会先发出一个首个键值（first-key）的请求，这个请求后紧跟着一些下一个键值（next-key）请求，面在有`ORDER BY DESC`的情况下，服务器会先发出一个最末键值（last-key）的请求，这个请求后紧跟着一些前一个键值（previous-key）的请求。这个变量在MySQL 5.6.1中被加入。

* Handler_read_next  
在键序列中读下一行的请求数。如果你在一个有索引的万上做范围查找或做一个索引扫描，这个值会增大。

* Handler_read_prev  
在键序列中读前一行的请求数。这个读方法主要是用来优化`ORDER BY ... DESC`的。

* Handler_read_rnd  
在一个固定位置读一行的请求数。如果你做了大量对结果排序的查询，这个值会很高。很可能你有大量需要MySQL扫描整表或是没有用键值的关联操作的查询。

* Handler_read_rnd_next  
在数据文件中读取下一行的请求数。如果你做了很多扫表操作，这个值会很大。一般来说这表明你的表没有被正确索引或你的查询没有写得能够利用到索引。

* Handler_rollback  
向存储引擎发送的执行rollback操作的请求数。

* Hanlder_savepoint  
向存储引擎发送的放置一个保存点（savepoint）的请求数。

* Handler_savepoint_rollback  
向存储引擎发送的执行rollback保存点操作的请求数。

* Handler_update  
更新表中一行的请求数。

* Handler_write  
向表中插入一行的请求数。

* Innodb_available_undo_logs  
可用的`InnoDB` [undo logs]的总数。是对[innodb_undo_logs]系统变量的补充，[innodb_undo_logs]表示有使用的undo logs的总数。

* Innodb_buffer_pool_dump_status  
记录在`InnoDB` [buffer pool][buffer_pool]中所持有的[pages][pages]的操作进度，由`innodb_buffer_pool_dump_at_shutdown`或`innodb_buffer_pool_dump_now`设置触发。

* Innodb_buffer_pool_load_status  
通过读取较早时间点对应的[pages][pages]集来预热`InnoDB` [buffer pool][buffer_pool]的操作进度，由[innodb_buffer_pool_load_at_startup]或[innodb_buffer_pool_load_now]设置触发。如果这个操作会造成负载过重，你可以用[innodb_buffer_pool_load_abort]来取消它。

* Innodb_buffer_pool_bytes_data  
`InnoDB` [buffer pool][buffer_pool]当前容纳数据的总字节数。这个数字包括脏（[dirty]）页和干净的页。当压缩（[compressed]）表引起buffer pool持有不同大小的页时，可以用它来计算比[Innodb_buffer_pool_pages_data]更精确的内存使用量。

* Innodb_buffer_pool_pages_data  
`InnoDB` [buffer pool][buffer_pool]当前容纳的数据的页数。这个数字包括脏（[dirty]）页和干净的页。

* Innodb_buffer_pool_bytes_dirty  
`InnoDB` [buffer pool][buffer_pool]当前所持有的脏页（[dirty_pages]）的字节数。当压缩（[compressed]）表引起buffer pool持有不同大小的页时，可以用它来计算比[Innodb_buffer_pool_pages_dirty]更精确的内存使用量。

* Innodb_buffer_pool_pages_dirty  
`InnoDB` [buffer pool][buffer_pool]当前所持有的脏页（[dirty_pages]）的总数。

* Innodb_buffer_pool_pages_flushed  
`InnoDB` [buffer pool][buffer_pool]刷新页面（[flush][pages][pages]）的请求数。

* Innodb_buffer_pool_pages_free  
`InnoDB` [buffer pool][buffer_pool]中空闲的页（[pages][pages][pages][pages]）数。

* Innodb_buffer_pool_pages_latched  
`InnoDB` [buffer pool][buffer_pool]中被锁住的页面（[pages][pages]）。它们是正在被读或写的页面，或是因为其它原因不能被刷新（[flushed]）或删除的页面。

* Innodb_buffer_pool_pages_misc  
`InnoDB` [buffer pool][buffer_pool]中因为被分配给管理开销而处于忙碌状态的页（[pages][pages]）数，如行锁（[row locks]）或自适应哈希索引([adaptive hash index])。这个值也可以用[Innodb_buffer_pool_pages_total] - [Innodb_buffer_pool_pages_free] - [Innodb_buffer_pool_pages_data]计算出来。

* Innodb_buffer_pool_pages_total  
`InnoDB` [buffer pool][buffer_pool]总大小，页（[pages][pages]）数。

* Innodb_buffer_pool_read_ahead  
通过后台预读进程读入`InnoDB` [buffer pool][buffer_pool]的页（[pages][pages]）数。

* Innodb_buffer_pool_read_ahead_evicted  
通过后台预读进程读入`InnoDB` [buffer pool][buffer_pool]的页因未被查询访问而踢出内存的页（[pages][pages]）数。

* Innodb_buffer_pool_read_requests   
`InnoDB` [buffer pool][buffer_pool]逻辑读请求数。这些请求可能通直接返回已经在内存中的数据来响应，或通读取首次从硬盘读取数据到内存的数据来响应。

* Innodb_buffer_pool_reads  
`InnoDB`可能不能满足从[buffer pool][buffer_pool]读取，而必须从直接从硬盘读取数据的逻辑读数。

* Innodb_buffer_pool_wait_free  
正常情况下，写入`InnoDB` [buffer pool][buffer_pool]是在后台发生的。当`InnoDB`需要读或创建一个页（[page][pages]）且没有干净的页可用时，`InnoDB`首先会刷新一些脏页（[dirty pages]）并等待操作结束这个计数器统计了这些等待的实例数。如果[innodb_buffer_pool_size]的值设置合理，这个值会非常小。

* Innodb_buffer_pool_write_requests  
`InnoDB` [buffer pool][buffer_pool]完成的写入次数。

* Innodb_data_fsyncs  
到目前为止`fsync()`的操作数。配置选项[innodb_flush_method]的设置影响`fsync()`的调用频率。

* Innodb_data_pending_fsyncs  
当前等待执行的`fsync()`操作的数目。配置选项[innodb_flush_method]的设置影响`fsync()`的调用频率。

* Innodb_data_pending_reads  
当前挂起的读取数。

* Innodb_data_pending_writes  
当前挂起的写数。


* Innodb_data_read  
从服务器起启后写入数据的总数。

* Innodb_data_reads  
读数据的总数。

* Innodb_data_writes  
写数据的总数。

* Innodb_data_written  
到目前为止写入数据的总字节数。

* Innodb_dblwr_pages_writes  
已经被写入到[doublewrite buffer]里的页（[pages][pages]）数。参考[5.3.1节，InnoDB 磁盘I/O]。

* Innodb_dblwr_writes  
双写（doublewrite）操作被执行的次数。参考[5.3.1节，InnoDB 磁盘I/O]。

* Innodb_have_atomic_builtins  
表示服务器是否使用[atomic instrucations]编译。

* Innodb_log_writes  
因[log buffer]太小需要等待（[wait]）刷新（[flushed]）后才能继续的次数。

* Innodb_log_write_requests
对`InnoDB` [redo log]的写请求次数。

* Innodb_log_writes  
对`InnoDB` [redo log]文件物理写的次数。

* Innodb_num_open_files  
`InnoDB`当前所持有打开的文件数。

* Innodb_os_log_fsyncs  
`fsync()`已经写入`InnoDB` [redo log]文件的数目。

* Innodb_os_log_pending_fsyncs  
等待执行的对`InnoDB` [redo log]文件写操作的数目。

* Innodb_os_log_written  
已经写入`InnoDB` [redo log]文件的字节数。

* Innodb_page_size  
编译的`InnoDB`页面大小（默认16K）。好多值在页面里就被计数；页面大小使得它们更容易被转为字节。

* Innodb_page_created  
`InnoDB`表操作创建的页数。

* Innodb_pages_read  
`InnoDB`表操作读取的页数。

* Innodb_pages_written  
`InnoDB`表操作写入的页数。

* Innodb_row_lock_current_waits  
`InnoDB`表操作正在等待行锁（[row lock][row_lock]）的数量。

* Innodb_row_lock_time  
获取`InnoDB`表行锁所花费的总时长，单位是微秒。

* Innodb_row_lock_time_avg  
获取`InnoDB`表行锁所花费的平均时长，单位是微秒。

* Innodb_row_lock_time_max  
获取`InnoDB`表行锁所花费的最大时长，单位是微秒。

* Innodb_row_lock_waits  
`InnoDB`表操作必须等待行锁（[row lock][row_lock]）的次数。

* Innodb_rows_deleted  
从`InnoDB`表中删除的行数。

* Innodb_rows_inserted  
向`InnoDB`表中插入的行数。

* Innodb_rows_read
从`InnoDB`表中读取的行数。

* Innodb_rows_updated
`InnoDB`表中更新的行数。

* Innodb_truncated_status_writes  
`SHOW ENGINE INNODB STATUS`语句输入被截断的次数。

* Key_blocks_not_flushed  
`MyISAM` key cache中已经发生改变但尚未刷到硬盘的主键块（key blocks）数。

* Key_blocks_unused  
`MyISAM` key cache中未被使用的块数。你可以用这个值来确定多少key cache在使用中；见[第5.1.4章，服务器系统变量]中[key_buffer_size]的讨论。

* Key_blocks_used  
`MyISAM` key cache中使用的块数。这个值是一个高水位标记表示曾经某个时刻使用块数的最大值。

* Key_read_requests  
从`MyISAM` key cache读取主键块（key blocks）的请求数。

* Key_reads  
从硬盘往`MyISAM` key cache中物理读取一个主键块（key block）的次数数。如果[Key_reads]值很大，你的[key_buffer_size]可能太小了。缓存未命中率可以用[Key_reads]/[Key_reads_requests]来计算。

* Key_write_requests
向`MyISAM` key cache写入主键块的请求数。

* Key_writes  
从`MyISAM` key cache往硬盘物理写入一个块的次数。

* Last_query_cost  
查询优化器计算的上个编译的查询的总开销。这对比较同一查询的不同执行计划非常有用。默认值0意味着目前还没有查询被编译。默认值为0。[Last_query_cost]是会话范围的。  
[Last_query_cost]的值能精确计算的是简单的查询，而不是那些有子查询或UNION的复杂查询。对于后者，它的值被设为0。

* Last_query_partial_plans  
查询优化器在为前一个查询创建执行计划构造器时的所迭代的次数。[Last_query_partial_plans]是会话范围的。这个变量是在MySQL 5.6.5中加入的。

* Max_used_connections  
自服务器启动以来同时使用的连接数的最大值。

* Not_flushed_delayed_rows  
等待使用`INSERT DELAYED`写入到非事务表中的行数。  
在MySQL 5.6.7中，这个状态变量是过期的（因为DELAYED插入已废弃），并且在将来的版本中会被移除。

* Open_files  
打开的表数。这个数包括服务器打开的常规文件。它不包括其它如套接字或管道等文件。这个数也不包括那些存储引擎使用自己内部方法打开而不是服务器层打开的文件。

* Open_streams  
打开的流数（主要用来记日志）。

* Open_table_definitions  
缓存的`.frm`文件数。

* Open_tables  
已经被打开的表数。如果[Open_tables]值很大，你的[table_open_cache]值可能设得太小了

* Performace_schema_xxx  
性能库（Performace Schema）状态变量列在[第21.13节，性能库状态变量]中。这些变量提供因为内存限制而无法加载或创建的监测信息。

* Prepared_stmt_count  
当前预编译语句的数量 。（预编译语句的最大数量由系统变量[max_prepared_stmt_count]提供。）

* Qcache_free_blocks  
查询缓存中空闲的内存块数。

* Qcache_free_memory  
查询缓存中空间内存的总大小。

* Qcache_hits  
命中查询缓存的数量。

* Qcache_inserts
加入到查询缓存中的查询数量。

* Qcache_lowmem_prunes  
因为内存不够而从查询缓存中删掉的查询数。

* Qcache_not_cached  
没有被缓存的查询数（没法缓存或因为[query_cache_type]设置而没有缓存）。

* Qcache_queries_in_cache  
在查询缓存中注册了的查询数量。

* Qcache_total_blocks  
查询缓存中总的块数。

* Queries  
服务器执行了的语句的数量。不像变量[Questions]，这个变量包括了在存储程序中执行的语句。它不统计`COM_PING`或`COM_STATISTICS`命令。

* Questions  
服务器执行了的语句的数量。不像变量[Queries]，它只包括由客户端发给服务器的语句，而不包括在存储程序中执行的语句。这个变量不统计`COM_PING`、`COM_STATISTICS`、`COM_STMT_PREPARE`、`COM_STMT_CLOSE`或`COM_STMT_RESET`命令。

* Rpl_semi_sync_master_clients  
半同步的从库数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_net_avg_wait_time  
主库等待从库回应的平均微秒数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_net_wait_time  
主库等待从库回应的总微秒数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_net_waits  
主库等待从库回应的总次数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_no_times  
主库关闭半同步复制的次数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_no_tx  
从库没有应答成功的提交数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_status  
半同步复制当时是否在主库上运行。如果这个插件已被启用，并且提交确认已经发生，这个值为`ON`。如果这个插件未被启用，或由于提交确认超时主库回到异步同步的状态，这个值为`OFF`。   
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_timefunc_failures  
主库在调用诸如`gettimeofday()`的时间函数时失败的次数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_tx_avg_wait_time  
主库等待每个事务的平均微秒数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_tx_wait_times  
主库等待事务的总微秒数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_masrer_tx_waits  
主库等待事务的总次数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_wait_pos_backtraverse  
主库等待一个二进制日志位置比之前等待的还要靠前的事件的次数。这种情况见于事务等待回应的时序与它们写入二进制日志时序不同时。[^Rpl_semi_sync_master_wait_pos_backtraverse]  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。
[^Rpl_semi_sync_master_wait_pos_backtraverse]: lark翻译：主库等待“回溯”事件（其二进制日志位置比之前等待的事件还要靠前的事件）的次数。“回溯”事件发生在事务等待回应的顺序与它们的事件写入日志的顺序不同时。

* Rpl_semi_master_wait_sessions  
当前等待从库应答的会话数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_master_yes_tx  
从库应答成功的提交数。  
这个变量只在主库端半同步复制插件（master-side semisynchronous replication plugin）安装了的情况下可用。

* Rpl_semi_sync_slave_status  
半同步复制当时是否在从库上运行。如果这个插件启用并且从库的I/O线程在运行，这个值为`ON`，否则为`OFF`。

* Rsa_public_key  
`sha256_password`验证插件所使用的RSA的公钥。这个值只有在服务器成功初始化了以系统变量[sha256_password_private_key_path]和[sha256_password_public_key_path]命名的文件时才不为空。[Rsa_public_key]的值来自后者文件。  
如需更多关于`sha256_password`信息，参考[每6.3.7.4节，SHA-256验证插件]。  
这个变量只在有MySQL使用了OpenSSL编译时有效。它是在MySQL 5.6.6中加入的。

* Select_full_join  
因为有用到索引而做全表扫描的join数。如果这个值不为0，你应该仔细检查表的索引。

* Select_full_range_join  
在引用表上做范围查找的join数。

* Select_range  
在第一张表上做范围查找的join数。即使这个值很大也不是什么大问题。

* Select_range_check  
在每一行数据后对键进行检查的不带键值的join数。如果这个值不为0，你应该仔细检查表的索引。

* Select_scan  
在第一张表上做了全表扫描的join数。

* Slave_heartbeat_period  
在一台复制从库上显示复制心跳间隔（单位为秒）。

* Slave_last_heartbeat  
以时间戳（[TIMESTAMP]）显示一台复制从库接收到最新的心跳信号的时间。

* Slave_open_temp_tables  
从库SQL线程当前打开的临时表个数。如果这个值大于0，关闭这台从库是不安全的。参考[第16.4.1.22，复制与临时表]。

* Slave_received_heartbeat  
自从库重启或重置（也就是[CHANGE MASTER TO]语句被执行）后，这个计数器在每次接收到复制从库心跳时递增。

* Slave_retried_transactions  
自从库起动以来复制从库SQL线程已经重试事务的次数。

* Slave_running  
如果服务器是一台连上了主库的从库，且I/O和SQL线程都在运行，这个值为`ON`，否则为`OFF`。

* Slow_launch_threads  
创建时间超过[slow_launch_time]秒的线程的数量。

* Slow_queries  
执行时间超过[ong_query_time]秒的查询数。该计数器不管慢查询日志是否启用都会递增。 如需更多关于这个日志的信息，参考[第5.2.5节，慢查询日志]。

* Sort_merge_passes  
排序算法已经执行的合并的数量，如果这个值较大，你可以考虑增加[sort_buffer_size]系统变量的大小一。

* Sort_range  
使用范围排序的数量。

* Sort_rows  
排完序的行数。

* Sort_scan  
通过扫描表完成的排序的数量。

* Ssl_accept_renegotiates  
建立连接时需要的协商的次数。

* Ssl_accepts  
接受了的SSL连接数。

* Ssl_callback_cache_hits  
SSL回调缓存命中的数量。

* Ssl_cipher  
当前的SSL密文（非SSL连接为空）。

* Ssl_cipher_list
可能的SSL密码列表。

* Ssl_client_connects  
尝试连接一个启用SSL主库的连接数。

* Ssl_connect_renegotiates  
建立一个启用SSL主库连接所需要的协商的次数。

* Ssl_ctx_verify_depth  
SSL上下文验证深度（即多少个链上的证书被测试）。

* Ssl_ctx_verify_mode  
SSL上下文验证模式

* Ssl_default_timeout  
默认的SSL超时时间。

* Ssl_finished_accepts  
成功连接到服务器的SSL连接数。

* Ssl_finished_connects  
成功连到启用SSL主库的从库连接数。

* Ssl_server_not_after  
SSL证书过期时间。这个变量在MySQL 5.6.3中被加入。

* Ssl_server_not_before  
SSL证书有效的起始时间。这个变量在MySQL 5.6.3中被加入。

* Ssl_session_cache_hits  
SSL会话缓存命中次数。

* Ssl_session_cache_misses
SSL会话缓存未命中次数。

* Ssl_session_cache_mode  
SSL会话缓存模式。

* Ssl_session_cache_overflows  
SSL会话缓存溢出次数。

* Ssl_session_cache_size  
SSL会话缓存大小。

* Ssl_session_cache_timeouts  
SSL会话缓存超时次数。

* Ssl_session_reused  
缓存中有多少个SSL连接被复用。

* Ssl_used_session_cache_entries  
多少个SSL会话缓存实体被使用。

* Ssl_verify_depth  
复制SSL连接的验深度。

* Ssl_verify_mode  
复制SSL连接验证模式。

* Ssl_version  
连接的SSL协议版本。

* Table_locks_immediate  
立即获得表锁的请求的次数。

* Table_locks_waited  
不能立即获得表锁且需要等待的请求的次数。如果这个值较高，你可能遇上了性能问题，你应该首先优化你的查询，然后拆分你的表或使用复制。

* Table_open_cache_hits  
在打开表缓存中查询的命中次数。这个变量在MySQL 5.6.6中被加入。

* Table_open_cache_misses
在打开表缓存中查询的未命中次数。这个变量在MySQL 5.6.6中被加入。  

* Table_open_cache_overflows  
打开表缓存溢数。这是当一个表打开或关闭后，缓存实例中有一个未使用的实体，它的大小比[table_open_cache]/[table_open_cache_instances]大的次数。这个变量在MySQL 5.6.6中加入。

* Tc_log_max_pages_used
对于mysqld所使用的内存映射实现的日志，当它被当成一个内部分布式事务恢复的事务协调器时，这个变量表示服务器启动以来的该日志所用的最大的页数。如果[Tc_log_max_page_used]和[Tc_log_page_size]的乘积总是小于该日志大小，那这个值就是大于所需，可以考虑降低它。（这个值用[--log-tc-size]选项来设置。）目前这个值是没啥用的：基于二进制日志的恢复用不上它，内存映射恢复的日志方法用不上，除非实现了两段式提交的存储引擎数大于1。（`InnoDB`是唯一支持的引擎。）

* Tc_log_page_size  
内存映射实现分布式恢复日志所使用的页大小。默认值可以用`getpagesize()`来确定。目前，因为和上面介绍的[Tc_log_max_page_used]一样的原因，这个值没啥毛用。

* Tc_log_page_waits  
对于内存映射实现分布式恢复日志，每次服务器不能提交一个事务不得不等待日志中一个空闲的页是，这个值会增加。如果这个值较大，你可能要增加日志大小（用[--log-tc-size]选项）。对于基于二进制日志的恢复，当二进制日志因程序中有两段式提交而不能提交时，这个值会增加。（关闭操作要一直等到像这样的事务全部关闭为止。）

* Threads_cached  
线程缓存中的线程数。

* Threads_connected  
当然打开的线程数。

* Threads_created  
创建了的用来处理连接的线程数。如果[Threads_created]值较大，你可能要增大[thread_cache_size]值，缓存命中率可以用[Threads_created]/[Connections]来计算。

* Threads_running  
非睡眠状态的线程数。

* Uptime  
服务器运行的总秒数。

* Uptime_since_flush_status  
从上次执行`FLUSH STATUS`到现在的总秒数。