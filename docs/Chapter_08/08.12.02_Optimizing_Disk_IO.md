### 8.12.2 Optimizing Disk I/O

Some system-level factors can affect performance in a major way:

*   If you have enough RAM, you could remove all swap devices. Some operating systems use a swap device in some contexts even if you have free memory.

*   Avoid external locking for [MyISAM][6] tables. The default is for external locking to be disabled. The [--external-locking][7] and [--skip-external-locking][8] options explicitly enable and disable external locThis section describes ways to configure storage devices when you can devote more and faster storage hardware to the database server. For information about optimizing an InnoDB configuration to improve I/O performance, see [Section 8.5.8, “Optimizing InnoDB Disk I/O”][9].
    *   Disk seeks are a huge performance bottleneck. This problem becomes more apparent when the amount of data starts to grow so large that effective caching becomes impossible. For large databases where you access data more or less randomly, you can be sure that you need at least one disk seek to read and a couple of disk seeks to write things. To minimize this problem, use disks with low seek times.

    *   Increase the number of available disk spindles (and thereby reduce the seek overhead) by either symlinking files to different disks or striping the disks:Using symbolic linksThis means that, for MyISAM tables, you symlink the index file and data files from their usual location in the data directory to another disk (that may also be striped). This makes both the seek and read times better, assuming that the disk is not used for other purposes as well. See [Section 8.12.3, “Using Symbolic Links”][1].Symbolic links are not supported for use with InnoDB tables. However, you can create an InnoDB [file-per-table][2]tablespace in a location outside of the MySQL data directory using the DATA DIRECTORY =absolute_path_to_directory clause of the [CREATE TABLE][3] statement. For more information, see [Section 14.7.5, “Creating a File-Per-Table Tablespace Outside the Data Directory”][4].StripingStriping means that you have many disks and put the first block on the first disk, the second block on the second disk, and the N-th block on the (N MOD number_of_disks) disk, and so on. This means if your normal data size is less than the stripe size (or perfectly aligned), you get much better performance. Striping is very dependent on the operating system and the stripe size, so benchmark your application with different stripe sizes. See [Section 8.13.3, “Using Your Own Benchmarks”][5].The speed difference for striping is very dependent on the parameters. Depending on how you set the striping parameters and number of disks, you may get differences measured in orders of magnitude. You have to choose to optimize for random or sequential access.

    *   For reliability, you may want to use RAID 0+1 (striping plus mirroring), but in this case, you need 2 × N drives to holdN drives of data. This is probably the best option if you have the money for it. However, you may also have to invest in some volume-management software to handle it efficiently.

    *   A good option is to vary the RAID level according to how critical a type of data is. For example, store semi-important data that can be regenerated on a RAID 0 disk, but store really important data such as host information and logs on a RAID 0+1 or RAID N disk. RAID N can be a problem if you have many writes, due to the time required to update the parity bits.

    *   You can also set the parameters for the file system that the database uses:If you do not need to know when files were last accessed (which is not really useful on a database server), you can mount your file systems with the -o noatime option. That skips updates to the last access time in inodes on the file system, which avoids some disk seeks.On many operating systems, you can set a file system to be updated asynchronously by mounting it with the -o async option. If your computer is reasonably stable, this should give you better performance without sacrificing too much reliability. (This flag is on by default on Linux.)

    king.Disabling external locking does not affect MySQL's functionality as long as you run only one server. Just remember to take down the server (or lock and flush the relevant tables) before you run [myisamchk][10]. On some systems it is mandatory to disable external locking because it does not work, anyway.The only case in which you cannot disable external locking is when you run multiple MySQL servers (not clients) on the same data, or if you run [myisamchk][11] to check (not repair) a table without telling the server to flush and lock the tables first. Note that using multiple MySQL servers to access the same data concurrently is generally notrecommended, except when using MySQL Cluster.The [LOCK TABLES][12] and [UNLOCK TABLES][13] statements use internal locking, so you can use them even if external locking is disabled.

[1]:optimization.html#symbolic-links
[2]:glossary.html#glos_file_per_table
[3]:sql-syntax.html#create-table
[4]:innodb-storage-engine.html#tablespace-placing
[5]:optimization.html#custom-benchmarks
[6]:storage-engines.html#myisam-storage-engine
[7]:server-administration.html#option_mysqld_external-locking
[8]:server-administration.html#option_mysqld_external-locking
[9]:optimization.html#optimizing-innodb-diskio
[10]:programs.html#myisamchk
[11]:programs.html#myisamchk
[12]:sql-syntax.html#lock-tables
[13]:sql-syntax.html#lock-tables