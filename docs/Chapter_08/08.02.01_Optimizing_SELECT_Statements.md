### 8.2.1.优化 SELECT 语句
以 [SELECT][SELECT] 语句形式的查询执行数据库所有的查找。调优这些语句是首先要做的事情，不管是获得动态网页的 子秒（sub-second）效应时间，还是砍掉数小时的来生成一整晚的报告。

#### [8.2.1.1.SELECT 语句的速度](#8.2.1.1)
优化查询主要考虑如下这几点：

* 要想一个慢速 SELECT ... WHERE 查询更快，第一件事是检查你能不能添加一个[索引][index]。在字段建立索引并在WHERE子句使用，来加速评估、过滤和最后结果的检索。构建一个小的能加速很多相关查询的索引集合应用于你的程序来避免浪费磁盘的空间。

	索引对于涉及几个表的查询特别重要，而这些表使用了例如[joins][joins]和[foreign keyss][foreign keyss]的特性。你可以使用[EXPLAIN][EXPLAIN]语句来确定哪些索引用于一个[SELECT][SELECT]语句。看[8.3.1章节，“MySQL怎样使用索引”][8.3.1]和[8.8.1章节“用EXPLAIN优化查询”][8.8.1]。

* 隔离和调整查询的部分，例如一个花费过多时间的函数调用。取决于查询是怎样构造的，一个函数或者会被结果集的每一行调用一次，或者甚至被表的每一行调用一次。极大地把效率低放大了。

* 在你的查询最小化[全表扫描][full table scans]的数量，特别是大表。

* 定期地使用[ANALYZE TABLE][ANALYZE TABLE]   语句来使表保持最新的统计,这样优化器有了需要去构造一个有效的执行计划的信息。

* 学习针对每张表存储引擎的调优技巧，索引技巧和配置参数。InnoDB和MyISAM两个存储引擎都有很多能使查询成为和维持高性能的指导方针。更详细的信息，查阅[章节8.5.5，“优化InnoDB查询”][8.5.5]和[章节8.6.1,“优化MyISAM查询”][8.6.1]。

* 特别地，在MySQL5.6.4和更高的版本，你可以使用[章节14.2.4.2.3，“为只读事务优化”][章节14.2.4.2.3，“为只读事务优化”]的技巧为InnoDB表优化单一查询的事务。

* 避免用令查询变得很难理解的方式来改变它们，特别是如果优化器自动地做一些相同的改变。

* 如果一个性能问题不容易被基本的指导方针解决，可以通过查看[EXPLAIN][EXPLAIN]计划和调整你的索引、WHERE子句、join子句等等。（当你获得了一定的专业知识后，查看EXPLAIN计划可能是你优化每一次查询的第一步）

* 调整MySQL用来做缓存的内存区域的大小和属性。随着InnoDB[缓冲池][buffer pool]、MyISAM关键字缓存和MySQL查询缓存的有效使用，重复的查询会变得更快，因为结果可以从内存二次和后续时间重新得到。

* 即使对于一个使用了内存区域而运行得很快的查询，你还是需要优化得更好，以便它们需要更少的缓存内存，使你的应用程序更容易扩展。扩展意味着你的应用程序能处理更多的用户同时访问、更大的请求等等而不会令到性能有一个很大的下降。

* 当你的查询速度会被其他同时访问同一张表的会话影响时，就要处理锁定问题。

#### [8.2.1.2.MySQL优化 WHERE 子句的原理](#8.2.1.2)

这个章节将会讨论能用于处理 WHERE 子句的优化。使用SELECT语句的例子，同样适用优化使用了DELETE和UPDATE语句的WHERE子句。 

	Note：因为在MySQL优化器调试的工作还在进行，不是所有MySQL执行的优化都会出现在文档这里。

你可能会被诱惑重写你的查询令到它们算法操作更快，而牺牲可读性。因为MySQL会自动地做相同的优化，所以你可以经常避免这种工作和让查询保持更容易理解和可持续的形式。一些由MySQL执行的优化如下：

* 去掉不需要的括号：
```sql
	((a AND b) AND c OR (((a AND b ) AND (c AND d))))
    ->(a AND b AND c ) OR (a AND b AND c AND d)
```

* 常量合并
```sql
	(a<b AND b=c) AND a=5
    b>5 AND b=c AND a=5 
```

* 移除常量条件（必须的，因为常量可以合并）
```sql
	(B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
	->B=5 OR B=6
```

* 被索引使用的常量表达式只被计算一次。

* 在一张表进行COUNT(*)[1303][]操作而没有使用 WHERE 时对于 MyISAM 和 MEMORY 表是可以直接从表信息取到的.对于在一张表使用任何的 NOT NULL 语句也是一样的。

* 非法常量表达式的早期检测。MySQL会快速检测一些无效的[SELECT][SELECT]语句和不会返回记录。

* 如果你没有使用 GROUP BY 或者聚合函数（例如COUNT(*)[1303][],MIN()[1305][]等），HAVING 和 WHERE 混合使用。

* 对于一个连接的每一张表，一个更简单的 WHERE 被构造来获得一个更快的 WHERE 估算而且会尽可能地跳过无关的行。

* 在查询中所有的静态表会比其他任何表先进行读。符合以下任何一种情况都可认为是一张静态表：

	* 一张空表或者只有一行的表。
	
	* 一张在主键和唯一索引上面使用了一个 WHERE 子句的表，而该表的所有索引都被比作常量表达式和被定义成非空。

	所有如下的表都被视为静态表：

	```sql
	SELECT * FROM t WHERE primary_key=1;
	SELECT * FROM t1,t2
		WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
	```
* 对于表的连接的最好连接组合是通过尝试所有的可能性来发现的。如果在ORDER BY和GROUP BY子句的所有列都来自同一张表，那么该表在连接的时候将会是优先的。

* 如果在一个连接队列里面有一个ORDER BY子句和一个不同的GROUP BY子句，或者如果ORDER BY或GROUP BY包含的列来自几张表，而这些表不同于第一张表，就会创建一张临时表。

* 如果你使用了 SQL_SMALL_RESULT 选项，MySQL会使用一张存在于内存的临时表。

* 每张表的所以都会被查询，而且最好的索引会被使用，除非优化器相信进行全表扫描更有效。同时，全表扫描是否会进行取决于最好的索引是否跨越了表的30%的范围，但是一个固定的比例不再决定选择使用索引还是全表扫描。现在的优化器变得更复杂和基于它对额外的因素(例如表的大小、行数和I/O块的大小)的衡量。

* 在一些情况下，MySQL能从索引读取行而不需要查询数据文件。如果索引所使用的列都是数值，那么只要使用索引树就可以解决查询了。

* 在每一行输出之前，那些没有匹配HAVING子句的行将会被忽略。

一些查询的例子是非常快的：
```sql
SELECT COUNT(*) FROM tb1_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tb1_name;

SELECT MAX(key_part2) FROM tb1_name
  WHERE key_part1=constant;

SELECT ... FROM tb1_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tb1_name
  ORDER BY key_part1 DESC, key_part2 DESC,... LIMIT10;
```

下列查询MySQL仅使用索引树就可以解决(假设索引的列为数值型)：

```sql
SELECT key_part1, key_part2 FROM tb1_name WHERE key_part1=val;

SELECT COUNT(*) FROM tb1_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tb1_name GROUP BY key_part1;
```
下列查询使用索引按排序顺序检索行，不用另外的排序：
```sql
SELECT ... FROM tb1_name
  ORDER BY key_part1, key_part2,... ;

SELECT ... FROM tb1_name
  ORDER BY key_part1 DESC, key_part2 DESC, ...;
```

#### [8.2.1.3.范围优化](#8.2.1.3)

[range][958]访问方法使用单一索引来搜索包含在一个或几个索引值距离内的表记录的子集。可以用于单部分或多元素索引。后面的章节将详细描述如何从WHERE子句提取区间。

##### 8.2.1.3.1.单元素索引的范围访问方法

对于单元素索引，可以用WHERE子句中的相应条件很方便地表示索引值区间，因此我们称为范围条件而不是“区间”。
单元素索引范围条件的定义如下：

* 对于BTREE和HASH索引，当使用=、<=>、IN、IS NULL或者IS NOT NULL操作符时，关键元素与常量值的比较关系对应一个范围条件。

* 对于BTREE索引，当使用>、<、>=、<=、BETWEEN、!=或者<>，或者LIKE 'pattern'(其中 'pattern'不以通配符开始)操作符时，关键元素与常量值的比较关系对应一个范围条件。

* 对于所有类型的索引，多个范围条件结合OR或AND则产生一个范围条件。

   前面描述的“常量值”系指：

* 查询字符串中的常量

* 同一联接中的const或system表中的列

* 无关联子查询的结果

* 完全从前面类型的子表达式组成的表达式

下面是一些WHERE子句中有范围条件的查询的例子：
```sql
SELECT * FROM t1 
    WHERE key_col > 1 
    AND key_col < 10;
 
SELECT * FROM t1 
    WHERE key_col = 1 
    OR key_col IN (15,18,20);
 
SELECT * FROM t1 
    WHERE key_col LIKE 'ab%' 
    OR key_col BETWEEN 'bar' AND 'foo';
```
请注意在常量传播阶段部分非常量值可以转换为常数。

MySQL尝试为每个可能的索引从WHERE子句提取范围条件。在提取过程中，不能用于构成范围条件的条件被放弃，产生重叠范围的条件组合到一起，并且产生空范围的条件被删除。

例如，考虑下面的语句，其中key1是有索引的列，nonkey没有索引：
```sql
SELECT * FROM t1 WHERE
   (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
   (key1 < 'bar' AND nonkey = 4) OR
   (key1 < 'uux' AND key1 > 'z');
```
key1的提取过程如下:

1. 用原始WHERE子句开始：
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```
2. 删除nonkey = 4和key1 LIKE '%b'，因为它们不能用于范围扫描。删除它们的正确途径是用TRUE替换它们，以便进行范围扫描时不会丢失匹配的记录。用TRUE替换它们后，可以得到：
```sql
 (key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1 < 'uux' AND key1 > 'z')
```
3.取消总是为true或false的条件：

* (key1 LIKE 'abcde%' OR TRUE)总是true

* (key1 < 'uux' AND key1 > 'z')总是false 

用常量替换这些条件，我们得到：
```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```
删除不必要的TRUE和FALSE常量，我们得到:
```sql
(key1 < 'abc') OR (key1 < 'bar')
```
4. 将重叠区间组合成一个产生用于范围扫描的最终条件:
```sql
(key1 < 'bar')
```
总的来说(如前面的例子所述)，用于范围扫描的条件比WHERE子句限制少。MySQL再执行检查以过滤掉满足范围条件但不完全满足WHERE子句的行。

范围条件提取算法可以处理嵌套的任意深度的AND/OR结构，并且其输出不依赖条件在WHERE子句中出现的顺序。

现在，MySQL已经对空间索引的range访问方法不再支持合并多范围了。为了适应这种限制，你可以在同一个 [SELECT][SELECT] 语句里使用一个 [UNION][UNION] ，除非你将每一个空间谓词放到了不同的 SELECT 语句。

##### 8.2.1.3.2.多元素索引的范围访问方法

多元素索引的范围条件是单元素索引的范围条件的扩展。多元素索引的范围条件将索引记录限制到一个或几个关键元组内。使用索引的顺序，通过一系列关键元组来定义关键元组区间。

例如，考虑定义为key1(key_part1, key_part2, key_part3)的多元素索引，以及下面的按关键字顺序所列的关键元组：
```sql
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
```
条件key_part1 = 1定义了下面的范围：
```sql
(1，-inf，-inf) <= (key_part1，key_part2，key_part3) < (1，+inf，+inf)
```
范围包括前面数据集中的第4、5和6个元组，可以用于范围访问方法。

通过对比，条件key_part3 = 'abc'不定义单一的区间，不能用于范围访问方法。

下面更加详细地描述了范围条件如何用于多元素索引中。

* 对于HASH索引，可以使用包含相同值的每个区间。这说明区间只能由下面形式的条件产生：
```sql
     key_part1 cmp const1
 AND key_part2 cmp const2
 AND ...
 AND key_partN cmp constN;
```
这里，const1，const2，...为常量，cmp是=、<=>或者IS NULL比较操作符之一，条件包括所有索引部分。(也就是说，有N 个条件，每一个对应N-元素索引的每个部分）。例如，下面为三元素HASH索引的范围条件：
```sql
key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
```
关于常量的定义，参见[8.2.1.3.1节，“单元素索引的范围访问方法”][8.2.1.3.1]。

*  对于BTREE索引，区间可以对结合AND的条件有用，其中每个条件用一个常量值通过=、<=>、IS NULL、>、<、>=、<=、!=、<>、BETWEEN或者LIKE 'pattern' (其中'pattern'不以通配符开头)比较一个关键元素。区间可以足够长以确定一个包含所有匹配条件(或如果使用<>或!=，为两个区间)的记录的单一的关键元组。例如，对于条件：
```sql
key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
```
单一区间为:
```sql
('foo'，10，10)< (key_part1，key_part2，key_part3)< ('foo'，+inf，+inf)
```
创建的区间可以比原条件包含更多的记录。例如，前面的区间包括值('foo'，11，0)，不满足原条件。

* 如果包含区间内的一系列记录的条件结合使用OR，则形成包括一系列包含在区间并集的记录的一个条件。如果条件结合使用了AND，则形成包括一系列包含在区间交集内的记录的一个条件。例如，对于两部分索引的条件：
```sql
(key_part1 = 1 AND key_part2 < 2) OR (key_part1 > 5)
```
区间为：

```sql
(1, -inf) < (key_part1, key_part2) < (1, 2)

(5, -inf) < (key_part1, key_part2)
```
在该例子中，第1行的区间左侧的约束使用了一个关键元素，右侧约束使用了两个关键元素。第2行的区间只使用了一个关键元素。[EXPLAIN][EXPLAIN]输出的key_len列表示所使用关键字前缀的最大长度。

在某些情况中，key_len可以表示使用的关键元素，但可能不是你所期望的。假定key_part1和key_part2可以为NULL。则key_len列显示下面条件的两个关键元素的长度：
```sql
key_part1 >= 1 AND key_part2 < 2
```
但实际上，该条件可以变换为：
```sql
key_part1 >= 1 AND key_part2 IS NOT NULL
```
[8.2.1.3.1节，“单元素索引的范围访问方法”][8.2.1.3.1节，“单元素索引的范围访问方法”] 描述了如何进行优化以结合或删除单元素索引范围条件的区间。多元素索引范围条件的区间的步骤类似。

##### 8.2.1.3.3.多值比较的相等范围优化

考虑下面的表达式， col_name 是一个索引列：
```sql
col_name IN (val1, ..., valN)
col_name = OR ... OR col_name = valN
```
如果 col_name 和几个值的任何一个相等，每个表达式都是true。这些比较都是相等范围的比较（这里的“范围”是一个单值）。优化器会为相等范围的比较评估读取符合资格的行所需要花费，例如如下：

* 如果在 col_name 有一个唯一的索引,对于每个范围的行评估是1，因为一行至多有一个给定的值。

* 显然，优化器通过深入索引或者索引统计能为每一个范围评估的行数。

随着索引dives，优化器在每一个范围的末端制造了一个dive和使用在范围里面的行数来作为评估。例如，表达式 col_name IN (10,20,30) 有3个平等范围，优化器为每个范围制造两个dives来形成一个行评估。每对dives产生已有给定值的行的数目的一个评估。


索引dives提供了准确的行评估，但是随着在语句里比较值的数量增加，优化器花费更长的时间去产生一个行评估。对于大数据的表单，使用索引统计准的确度比索引dives低，但是允许更快的行评估。

[eq\_range\_index\_dive\_limit][eq\_range\_index\_dive\_limit]系统变量可以让你来配置那些优化器从一个行评估策略转换到其他策略的值的数量。想让统计的使用失效和总是使用索引dives，设置[eq\_range\_index\_dive\_limit][eq\_range\_index\_dive\_limit]为0，允许一直到 N 相等范围的比较使用索引dives，设置[eq\_range\_index\_dive\_limit][eq\_range\_index\_dive\_limit]为 N+1.

[eq\_range\_index\_dive\_limit][eq\_range\_index\_dive\_limit]从MySQL5.6.5是可用的。MySQL5.6.5之前的版本，优化器使用索引dives，相当于[eq\_range\_index\_dive\_limit=0][eq\_range\_index\_dive\_limit].

想得到最好的评估，使用 [ANALYZE TABLE][ANALYZE TABLE] 来更新表索引的统计。

#### 8.2.1.4索引合并优化

*索引合并*方法用于通过[range][range]扫描搜索行并将结果合成一个。合并会产生并集、交集或者正在进行的扫描的交集的并集。

在[EXPLAIN][EXPLAIN]输出中，该方法表现为type列内的[index_merge][index_merge]。在这种情况下，key列包含一列使用的索引，key_len包含这些索引的最长的关键元素。

例如：
```sql
SELECT * FROM tbl_name WHERE key_part1 = 10 OR key_part2 = 20;

 

SELECT * FROM tbl_name

    WHERE (key_part1 = 10 OR key_part2 = 20) AND non_key_part=30;

 

SELECT * FROM t1, t2

    WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')

    AND t2.key1=t1.some_col;

 

SELECT * FROM t1, t2

    WHERE t1.key1=1

    AND (t2.key1=t1.some_col OR t2.key2=t1.some_col2);
```
索引合并方法有几种访问算法 (参见[EXPLAIN][EXPLAIN]输出的*Extra*字段)：

* 交集

* 联合

* 排序并集

后面几节更加详细地描述了这些方法。

	索引合并优化算法具有以下几个已知缺陷：

	如果可以对某些关键字进行范围扫描，则不考虑索引合并。例如，下面的查询：

	SELECT * FROM t1 WHERE (goodkey1 < 10 OR goodkey2 < 20) AND badkey < 30;
	对于该查询，可以有两个方案：

	使用(goodkey1 < 10 OR goodkey2 < 20)条件进行索引合并扫描。

	使用badkey < 30条件进行范围扫描。

	然而，优化器只考虑第2个方案。
索引合并访问方法和其他访问方法的不同的可能变形体之间的选择是取决于多种可用选择的评估花费。

###### 8.2.1.4.1.索引合并交集访问算法

该访问算法可以用于当**WHERE**子句结合[AND][AND]被转换为不同的关键字的几个范围条件，每个条件为下面之一：

* 以这种形式，即索引有确切的**N**部分(即包括了所有索引部分)：
```sql
key_part1=const1 AND key_part2=const2 ... AND key_partN=constN
```
* 任何**InnoDB**表的主键的范围条件。

下面是一些例子：
```sql
SELECT * FROM innodb_table WHERE primary_key < 10 AND key_col1=20;

SELECT * FROM tbl_name
  WHERE (key1_part1=1 AND key1_part2=2) AND key2=2;
```
索引合并交集算法同时对所有使用的索引进行扫描，并产生从合并的索引扫描接收的行序列的交集。

如果使用的索引包括查询中使用的所有列，所有表记录均不搜索，并且在这种情况下[EXPLAIN][EXPLAIN]的输出包含**Extra**字段中的**Using index**。下面是一个此类查询的例子：
```sql
SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
```
如果使用的索引未包括查询中使用的所有列，只有满足所有使用的关键字的范围条件才搜索所有记录。

如果某个合并条件是InnoDB或BDB表的主键的一个条件，不用于记录查询，但用于过滤使用其它条件搜索的记录。

##### 8.2.1.4.2.索引合并并集访问算法
该算法的适用标准类似于索引合并方法交集算法的标准。算法可以用于当**WHERE**子句结合[OR][OR]被转换为不同的关键字的几个范围条件的时候，每个条件为下面之一：

* 以这种形式，即索引有确切的N部分(即包括了所有索引部分)：
```sql
key_part1=const1 AND key_part2=const2 ... AND key_partN=constN
```
* 任何InnoDB或BDB表的主键的范围条件。

* 索引合并方法交集算法适用的一个条件。

下面是一些例子：
```sql
SELECT * FROM t1 WHERE key1=1 OR key2=2 OR key3=3;
 
SELECT * FROM innodb_table WHERE (key1=1 AND key2=2) OR
  (key3='foo' AND key4='bar') AND key5=5;
```
##### 8.2.1.4.3.索引合并排序并集访问算法
该访问算法可以用于当**WHERE**子句结合[OR][OR]被转换为不同的关键字的几个范围条件，但索引合并方法联合算法并不适用的时候。

下面是一些例子：
```sql
SELECT * FROM tbl_name WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name

  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col=30;
```
排序联合算法和联合算法的区别是排序联合算法必须先索取所有记录的行ID，然后在返回记录前对它们进行排序。

#### 8.2.1.5.引擎条件叠加优化

这种优化提高了一个索引列和一个常量直接比较的效率。在这种情况下，条件对于存储引擎的评估是“叠加”的。这种优化仅仅能被用于[NDB][NDB]存储引擎。

对于MySQL集群，这种优化能消除通过网络传输不匹配行的花费和MySQL服务器发布的查询，而且能加快那些在多种情况被一个因子使用了5到10次的查询，而这个因子是可以条件叠加，但实际没有。

假设一张MySQL集群定义如下：

```sql    

CREATE TABLE t1 (  
      a INT,  
	  b INT,  
	  KEY(a)  
)ENGINE=NDB;  
```  

条件叠加能与下面的一条查询使用，这条查询包括了一个非索引列和常量的比较：

```sql
SELECT * FROM t1 WHERE b = 10;
```
条件叠加的使用情况可以通过EXPLAIN输出来查看：
```sql
mysql>EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G
*******************1.row**************************
           id: 1
    select_type: SIMPLE
        table: t1
         type: ALL
    possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
```
但是，条件叠加不能用在下面两种情况：
```sql
SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
```
条件叠加不可应用于第一种查询是因为已经有一个索引在字段**a**了。（一个索引的访问方法可能更有效，所以比条件叠加会被优先选择。）条件叠加不能应用于第二种查询是因为比较间接地涉及到了非索引列**b**。（但是，如果你在**where**子句分解 **b + 1 = 10** 成为**b = 9**条件，条件叠加是可以应用的。）

当用一个**>**或者**<**进行索引列与常量的比较时，条件叠加也许能被应用：

```sql
mysql> **EXPLAIN SELECT a,b FROM t1 WHERE a<2\G** 
*************************** 1. row ***************************  

           id: 1  

  select\_type: SIMPLE  

        table: t1

         type: range  
possible\_keys: a

          key: a

      key\_len: 5

          ref: NULL

         rows: 2

        Extra: Using where with pushed condition

```

其他条件叠加支持的比较包括下面这些：

* **column [NOT] LIKE pattern**

  **pattern**必须是一个包括的模式能被匹配的字符串；对于语法，查看章节[12.5.1 字符比较函数][12.5.1]  
   
* **column IS [NOT] NULL**

* **column IN (value_list)**

  每一个**value_list**里面的条目必须是一个常量字面值。

* **column BETWEEN constant1 AND constant2**

  **constant1** 和 **constant2** 每个都必须是一个常量字面值

在前面列表的所有情况里，条件是可能被转换成一个列和一个常量之间的一种或多种直接比较的形式。

引擎条件叠加默认是可行的。要让它失效，在服务器启动的时候设置系统变量**optimizer_switch**。例如在一个**my.cnf**文件，使用下面这些行：

```sql

[mysqld]  
optimizer\_switch=engine\_condition\_pushdown=off

```
在运行时让条件叠加失效：
```sql

SET optimizer\_switch='engine\_condition\_pushdown=off';

```

**局限性**。 引擎条件叠加受下面这些限制的约束：

* 条件叠加只能有[NDB][NDB]存储引擎支持。

* 列或者只会和常量比较；但是这包括了那些评估为常量值的表达式。

* 在表达式里使用的列不能是[BLOB][11.4.3]或者[TEXT][11.4.3]类型。

* 一个字符串值要和一个列比较必须要和这个列是用一种校对。   

* 不直接支持链接；涉及多表的条件在合适的地方是被单独叠加的。使用**EXPLAIN EXTENDED**来决定哪个条件是实际上叠加的。

#### 8.2.1.6.索引条件叠加优化

索引条件叠加（ICP）是一种MySQL使用索引从一个表检索数据的情况的优化。没有ICP，存储引擎来回移动索引来定位基本表的位置和返回它们到为行评估**WHERE**条件的MySQL服务器。随着ICP的可用，如果**WHERE**条件的部分能通过仅仅使用索引的字段被评估，MySQL服务器会把这部分的**WHERE**条件叠加到存储引擎。存储引擎然后通过使用索引条目评估索引条件叠加，而且只有这样才满足记录是从表读取。ICP能降低存储引擎必须访问基本表的次数和MySQL服务器必须访问存储引擎的次数。

当有需要访问表的所有行时，索引条件叠加优化将被用于**range**,**ref**,**eq_ref**和**ref_or_null**访问方法。这个策略使用于**InnoDB**和**MyISAM**表。但是，对于**InnoDB**表ICP只能用于第二索引。ICP的目标是降低全记录读取从而降低IO操作。对于**InnoDB**簇索引，完整的记录已经被读进**InnoDB**缓存。在这种情况下使用ICP不会减低IO。

要了解这种优化的原理，首先要思考当索引条件叠加不能用时一个索引扫描时怎样进行的：

1.获得下一行，首先通过读取索引元组，然后通过索引元组定位和读取全表行。

2.检验应用于这个表的**WHERE**条件的一部分。接受或者拒绝行取决于检验结果。

当索引条件叠加被使用，扫描反而像这样进行：

1.获取下一行的索引元组（不是全表行）。

2.检验应用于这个表的**WHERE**条件的一部分，并且能被检查仅仅使用索引列。如果条件不满足，进入索引元组的下一行。

3.如果条件满足，使用索引元组来定位和读取全表行。

4.检验应用于这个表的**WHERE**条件的剩下部分，接受或者拒绝行取决于检验结果。

当索引条件叠加被使用，**EXPLAIN**输出的**Extra**列显示了**Using index condition**。它不会显示**Index only**,因为当全表的行被读取时不会被应用。

假如有一个关于人们和他们的地址信息的表和表有一个被定义为**INDEX（zipcode,listname,firstname）**的索引。如果我们知道一个人的**zipcode**值，但不确定lastname,我们可以像这样搜索：

```sql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%ertunia%'
  AND address LIKE '%Main Street%';
```

MySQL能通过**zipcode=‘95054’**使用索引来扫描人们的信息。第二部分（**lastname LIKE '%ertunia'）不能被用于限制必须被扫描的行的数目。所以没有索引条件叠加，这个查询必须为那些**zipcode='95054'**的人们检索全表的行。

因为索引条件叠加，MySQL在读取全表的行之前会检查**lastname LIKE '%etrunia%'**部分。这样就避免了读取全部行相当于所有没有匹配**lastname**条件的索引元组。


索引条件叠加默认是可用的；它也能被**optimizer_switch**系统变量控制通过设置**index_condition_pushdown**标志。查看[章节8.8.5.2,控制可转换的优化][8.8.5.2]

#### 8.2.1.7.索引扩展的使用

[InnoDB][InnoDB]通过附加主键到第二索引自动地扩展每一个第二索引。考虑如下定义：

```sql

    CREATE TABLE t1 (

    i1 INT NOT NULL DEFAULT 0,

    i2 INT NOT NULL DEFAULT 0,

    d DATE DEFAULT NULL,

    PRIMARY KEY (i1, i2),

    INDEX k_d (d)

    ) ENGINE = InnoDB;

```

这张表在列**（i1,i2）**定义了主键。它也在列**（d）**定义了一个第二索引，但是在内部InnoDB扩展了这个列并且把它作为了列**（d,i1,i2)**。

在MySQL5.6.9之前，优化器当决定怎样或者是否使用一个索引时没有将扩展的第二索引的主键列考虑在内。从MySQL5.6.9起，将主键列考虑在内，这样能带来更高效的查询执行计划和更好地性能。

优化器能为如下几种情况使用扩展的第二索引：**ref**,**range**和**index_merge**索引访问、松散的索引扫描、连接和排序优化、**MIN（）**/**MAX()**优化。

下面的例子展示了优化器是否使用扩展的第二索引是怎样影响执行计划的。假设**t1**是由这些行填充的：

```sql

    INSERT INTO t1 VALUES

    (1, 1, '1998-01-01'), (1, 2, '1999-01-01'),

    (1, 3, '2000-01-01'), (1, 4, '2001-01-01'),

    (1, 5, '2002-01-01'), (2, 1, '1998-01-01'),

    (2, 2, '1999-01-01'), (2, 3, '2000-01-01'),

    (2, 4, '2001-01-01'), (2, 5, '2002-01-01'),

    (3, 1, '1998-01-01'), (3, 2, '1999-01-01'),

    (3, 3, '2000-01-01'), (3, 4, '2001-01-01'),

    (3, 5, '2002-01-01'), (4, 1, '1998-01-01'),

    (4, 2, '1999-01-01'), (4, 3, '2000-01-01'),

    (4, 4, '2001-01-01'), (4, 5, '2002-01-01'),

    (5, 1, '1998-01-01'), (5, 2, '1999-01-01'),

    (5, 3, '2000-01-01'), (5, 4, '2001-01-01'),

    (5, 5, '2002-01-01');

```

现在考虑这个查询：

```sql

    EXPALIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'

```

优化器在这种情况不能使用主键，因为主键包含了列**（i1,i2）**而这个查询没有引用到**i2**。相反，优化器能在**d**使用第二索引**k_d**,执行计划取决于扩展索引是否被使用。

如果优化器不考虑索引扩展，它只会将索引**k_d**看成**（d）**。查询的**EXPLAIN**结果如下：

```sql


   mysql> EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G

    *************************** 1. row ***************************

    id: 1

    select_type: SIMPLE

    table: t1

    type: ref

    possible_keys: PRIMARY,k_d

    key: k_d

    key_len: 4

    ref: const

    rows: 5

    Extra: Using where; Using index

```

当优化器将索引扩展考虑进来，它将**k_d**看作**（d,i1,i2)**。在这种情况下，优化器能使用最左边的索引前缀**（d,i1)**来产生一个更好地执行计划：

```sql

    *************************** 1. row ***************************

			    id: 1
			
        select\_type: SIMPLE
			
			    table: t1
			
			    type: ref
			
	  possible\_keys: PRIMARY,k\_d
			
			    key: k_d
			
			    key_len: 8
			
			    ref: const,const
			
			    rows: 1
			
			    Extra: Using index

```

上面的两种情况，**key**表明优化器都会使用第二索引**k_d**但是**EXPLAIN**输出展示了使用扩展索引的改进：

* **key_len**从4个字节到8个字节，表明了键检查使用了列**d**和**i1**,而不仅仅是**d**。

* **ref**从**const**改变为**const,const**,因为键检查使用了两个键，而不是一个。

* **rows**数从5降到1，表明**InnoDB**需要检查更少的行来产生结果。

* **Extra**值从**Using where；Using index**改变为**Using index**。这样就意味着能仅仅使用索引获取所需的行，没有从数据行里查阅列。

对于使用扩展索引的不同优化器行为也可以通过**SHOW STATUS**来查看：

```sql

	FLUSH TABLE t1;
	
	FLUSH STATUS;
	
	SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01';
	
	SHOW STATUS LIKE 'handler_read%'

```

前面的语句包括了**FLUSH TABLE**和**FLUSH STATUS** 来刷新表缓存和清除状态计数。

没有索引扩张，**SHOW STATUS**产生这样的结果：

```sql
	
	+-----------------------+-------+
	
	| Variable_name         | Value |
	
	+-----------------------+-------+
	
	| Handler_read_first    | 0     |
	
	| Handler_read_key      | 1     |
	
	| Handler_read_last     | 0     |
	
	| Handler_read_next     | 5     |
	
	| Handler_read_prev     | 0     |
	
	| Handler_read_rnd      | 0     |
	
	| Handler_read_rnd_next | 0     |
	
	+-----------------------+-------+

```

因为索引扩展，**SHOW STATUS**	产生了下面的结果，**Handler_read_next**值从5降到1，表明了更有效地使用了索引：

```sql

	+-----------------------+-------+
	
	| Variable_name         | Value |
	
	+-----------------------+-------+
	
	| Handler_read_first    | 0     |
	
	| Handler_read_key      | 1     |
	
	| Handler_read_last     | 0     |
	
	| Handler_read_next     | 1     |

    | Handler_read_prev     | 0     |

    | Handler_read_rnd      | 0     |

    | Handler_read_rnd_next | 0     |

    +-----------------------+-------+

```

**optimizer_switch**系统变量的**use_index_extensions**标志允许控制当决定怎样使用一个**InnoDB**表的第二索引时控制器是否将主键列考虑进来。默认情况下，**use_index_extensions**是可用的。可以只用下面的语句来检查索引扩展是否禁用会提高效率：

```sql

SET optimizer_switch = 'use_index_extensions = off';

```
通过优化器使用索引扩展是受键数目的限制，一个索引是16,而且最大的键长度是3072字节。


#### 8.2.1.8.**IS NULL**优化

MySQL可以对可以结合**col_name = constant_value**使用的**col_name IS NULL**进行相同的优化。例如，MySQL可以使用索引和范围用**IS NULL**搜索**NULL**。

```sql

	SELECT * FROM tbl_name WHERE key_col IS NULL;
	 
	SELECT * FROM tbl_name WHERE key_col <=> NULL;
	 
	SELECT * FROM tbl_name
	
	    WHERE key_col=const1 OR key_col=const2 OR key_col IS NULL;

```
如果**WHERE**子句包括声明为**NOT NULL**的列的**col_name IS NULL**条件，表达式则优化。当列会产生**NULL**时，不会进行优化；例如，如果来自**LEFT JOIN**左侧的表。

MySQL也可以优化组合**col_name = expr AND col_name IS NULL**，这是解决子查询的一种常用形式。当使用优化时**EXPLAIN**显示**ref_or_null**。

该优化可以为任何关键元素处理**IS NULL**。

下面是一些优化的查询例子，假定表t2的列a和b有一个索引：

```sql

	SELECT * FROM t1 WHERE t1.a=expr OR t1.a IS NULL;
	 
	SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;
	 
	SELECT * FROM t1, t2
	    WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;
	 
	SELECT * FROM t1, t2
	    WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);
	 
	SELECT * FROM t1, t2
	    WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
	    OR (t1.a=t2.a AND t2.a IS NULL AND ...);

```

**ref_or_null**首先读取参考关键字，然后单独搜索**NULL**关键字的行。

请注意该优化只可以处理一个**IS NULL**。在后面的查询中，MySQL只对表达式**(t1.a=t2.a AND t2.a IS NULL)**使用关键字查询，不能使用**b**的关键元素：

```sql

	SELECT * FROM t1, t2
	     WHERE (t1.a=t2.a AND t2.a IS NULL)
	     OR (t1.b=t2.b AND t2.b IS NULL);

```

#### 8.2.1.9.LEFT JOIN和RIGHT JOIN优化

在MySQL中，**A LEFT JOIN B join_condition**执行过程如下：

* 根据表**A**和**A**依赖的所有表设置表**B**。

* 根据**LEFT JOIN**条件中使用的所有表(除了**B**)设置表**A**。

* **LEFT JOIN**条件用于确定如何从表**B**搜索行。(换句话说，不使用**WHERE子**句中的任何条件）。

* 可以对所有标准联接进行优化，只是只有从它所依赖的所有表读取的表例外。如果出现循环依赖关系，MySQL提示出现一个错误。

* 进行所有标准**WHERE**优化。

* 如果A中有一行匹配**WHERE**子句，但**B**中没有一行匹配**ON**条件，则生成另一个**B**行，其中所有列设置为**NULL**。

* 如果使用**LEFT JOIN**找出在某些表中不存在的行，并且进行了下面的测试：**WHERE**部分的**col_name IS NULL**，其中**col_name**是一个声明为 **NOT NULL**的列，MySQL找到匹配**LEFT JOIN**条件的一个行后停止(为具体的关键字组合)搜索其它行。

**RIGHT JOIN**的执行类似**LEFT JOIN**，只是表的角色反过来。

联接优化器计算表应联接的顺序。**LEFT JOIN**和**STRAIGHT_JOIN**强制的表读顺序可以帮助联接优化器更快地工作，因为检查的表交换更少。请注意这说明如果执行下面类型的查询，MySQL进行全扫描**b**，因为**LEFT JOIN**强制它在**d**之前读取：

```sql

	SELECT *
	    FROM a,b LEFT JOIN c ON (c.key=a.key) 
		LEFT JOIN d ON (d.key=a.key)
	    WHERE b.key=d.key;

```

在这种情况下修复时用a的相反顺序，b列于FROM子句中：

```sql

	SELECT *
	    FROM b,a LEFT JOIN c ON (c.key=a.key) 
		LEFT JOIN d ON (d.key=a.key)
	    WHERE b.key=d.key;

```

MySQL可以进行下面的**LEFT JOIN**优化：如果对于产生的**NULL**行，**WHERE**条件总为假，**LEFT JOIN**变为普通联接。

例如，在下面的查询中如果**t2.column1**为**NULL**，**WHERE **子句将为false：

```sql

SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;

```

因此，可以安全地将查询转换为普通联接：

```sql

SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;

```

这样可以更快，因为如果可以使查询更佳，MySQL可以在表**t1**之前使用表**t2**。为了强制使用表顺序，使用**STRAIGHT_JOIN**。(查看章节[13.2.9,**SELECT 语法**][SELECT])

#### 8.2.1.10.内循环连接算法

MySQL执行表之间的连接时使用一个嵌套循环算法或者它的一个变形。

**嵌套循环连接算法**

一个简单的嵌套循环连接（NLJ）算法在一个循环里面从第一个表每次读取一行，然后传递每一行给在连接中处理下一张表的嵌套循环。这个处理过程随着剩余的表被连接循环多次。

假设在**t1**,**t2**和**t3**三张表的一个连接使用如下的连接类型被执行：

```sql
	
	Table   Join Type
	
	t1      range
	
	t2      ref
	
	t3      ALL

```

如果使用了一个简单的NLJ算法，连接过程大概如下：

```sql

	for each row in t1 matching range {
	
	 for each row in t2 matching reference key {
	
	   for each row in t3 {
	
	    if row satisfies join conditions,
	
	    send to client
	
	   }
	
	 }
	
	}

```

因为NLJ算法从外层循环到内层循环是一次传递一行，所以代表性地在内层循环读取表的处理会进行多次。

**块嵌套循环连接算法**

一个块嵌套循环（BNL）连接算法在外层循环使用了行读取的缓冲区来减少表在内循环必须被读到的次数。例如，如果10行被读进缓冲区，而这个缓冲区被传递给下一个内循环，这样内循环的每一行能在缓冲区里面和所有的10行比较。减少了一个内表必须被读取次数的数量级。

MySQL在下面这些条件使用连接缓冲：

* **join_buffer_size**系统变量决定了每一个连接缓冲的大小。

* 当连接是**ALL**或**index**（换句话说，当没有可能的键使用时，一个全表扫描会被执行，数据或索引行，单独地）或**range**类型时连接缓冲会被使用.在MySQL5.6，缓冲的使用被延伸应用到外连接，正如[章节8.2.1.14,块嵌套循环和批键][8.2.1.14]描述。

* 每个能被缓冲的连接都会分配一个缓冲区，所以一个给定的查询应该会使用多个连接缓冲处理。

* 一个连接缓冲从不会被分配到第一个非常量表，即使它是**ALL**或**index**类型。

* 一个连接缓冲区在执行连接之前被分配，而且查询执行之后会被清空。

* 只有连接感兴趣的列会被存储在连接缓冲区，而不是整行。

举一个NLJ算法（没有缓冲）的连接描述例子，连接会像使用连接缓冲执行：

```sql
	
	for each row in t1 matching range {
	
	 for each row in t2 matching reference key {
	
	   store used columns from t1, t2 in join buffer
	
	   if buffer is full {

	    for each row in t3 {
	
	    for each t1, t2 combination in join buffer {
	
	    if row satisfies join conditions,
	
	    send to client
	
	    893
	
	    Optimizing SELECT Statements
	
	    }
	
	    }
	
	    empty buffer
	
	    }
	
	    }
	
	    }
	
	    if buffer is not empty {
	
	    for each row in t3 {
	
	    for each t1, t2 combination in join buffer {
	
	    if row satisfies join conditions,
	
	    send to client
	
	    }
	
	    }
	
	    }

```

如果**S**是每次存储**t1**的大小，**t2**组合是连接缓冲区和**C**是缓冲区里组合的数量，**t3**被扫描的次数是：

	（S * C）/join_buffer_size + 1

**t3**的扫描次数会随着**join_buffer_size**的上升而下降，当**join_buffer_size**上升到它能保存全部之前的行组合的点时，在那个点，不能通过令它更大来获得更高的速度。

#### 8.2.1.11.嵌套连接优化

表示联接的语法允许嵌套联接。下面的讨论引用了[13.2.9.2节，“JOIN语法”中描述的联接语法][13.2.9.2]。

同SQL标准比较，**table_factor**语法已经扩展了。后者只接受**table_reference**，而不是括号内所列的。

**table_reference**项列表内的每个逗号等价于内部联接，这是一个保留扩展名。例如：

```sql

	SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

```

等价于：

```sql

	SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

```

在MySQL中，**CROSS JOIN**语法上等价于**INNER JOIN** (它们可以彼此代替。在标准SQL中，它们不等价。**INNER JOIN**结合**ON**子句使用；**CROSS JOIN** 用于其它地方。

总的来说，在只包含内部联接操作的联接表达式中可以忽略括号。删除括号并将操作组合到左侧后，联接表达式：

```sql

	t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
       ON t1.a=t2.a

```
转换为表达式：

```sql

	(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    	ON t2.b=t3.b OR t2.b IS NULL

```
但是这两个表达式不等效。要说明这点，假定表**t1**、**t2**和**t3**有下面的状态：

* 表t1包含行{1}、{2}

* 表t2包含行{1,101}

* 表t3包含行{101}

在这种情况下，第1个表达式返回包括行{1,1,101,101}、{2,NULL,NULL,NULL}的结果，第2个表达式返回行{1,1,101,101}、{2,NULL,NULL,101}：

```sql

	mysql> SELECT *
	    -> FROM t1
	    ->      LEFT JOIN
	    ->      (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
	    ->      ON t1.a=t2.a;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL | NULL |
	+------+------+------+------+
	 
	mysql> SELECT *
	    -> FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)
	    ->      LEFT JOIN t3
	    ->      ON t2.b=t3.b OR t2.b IS NULL;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL |  101 |
	+------+------+------+------+

```

在下面的例子中，外面的联接操作结合内部联接操作使用：

```sql

t1 LEFT JOIN (t2，t3) ON t1.a=t2.a

```sql

该表达式不能转换为下面的表达式：

```sql

t1 LEFT JOIN t2 ON t1.a=t2.a，t3.

```
对于给定的表状态，第1个表达式返回行{1,1,101,101}、{2,NULL,NULL,NULL}，第2个表达式返回行{1,1,101,101}、{2,NULL,NULL,101}：

```sql
	
	mysql> SELECT *
	    -> FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL | NULL |
	+------+------+------+------+
	 
	mysql> SELECT *
	    -> FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL |  101 |
	+------+------+------+------+

```

因此，如果我们忽略联接表达式中的括号连同外面的联接操作符，我们会改变原表达式的结果。

更确切地说，我们不能忽视左外联接操作的右操作数和右联接操作的左操作数中的括号。换句话说，我们不能忽视外联接操作中的内表达式中的括号。可以忽视其它操作数中的括号(外部表的操作数)。

对于任何表**t1、t2、t3**和属性**t2.b**和**t3.b**的任何条件**P**，下面的表达式：

```sql

(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)

```

等价于表达式 

```sql

t1，t2 LEFT JOIN t3 ON P(t2.b,t3.b)

```
如果联接表达式(**join_table**)中的联接操作的执行顺序不是从左到右，我们则应讨论嵌套的联接。这样，下面的查询：

```sql

SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a > 1
 
SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a > 1

```
联接表：

```sql

t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3

```
认为是嵌套的。第1个查询结合左联接操作则形成嵌套的联接，而在第二个查询中结合内联接操作形成嵌套联接。

在第1个查询中，括号可以忽略：联接表达式的语法结构与联接操作的执行顺序相同。但对于第2个查询，括号不能省略，尽管如果没有括号，这里的联接表达式解释不清楚。(在外部扩展语法中，需要第2个查询的**(t2，t3)**的括号，尽管从理论上对查询分析时不需要括号：这些查询的语法结构将仍然不清楚，因为**LEFT JOIN**和**ON**将充当表达式**(t2,t3)**的左、右界定符的角色)。

前面的例子说明了这些点：

* 对于只包含内联接(而非外联接)的联接表达式，可以删除括号。你可以移除括号并从左到右评估(或实际上，你可以按任何顺序评估表)。

* 总的来说，对外联接却不是这样。去除括号可能会更改结果。
* 总的来说，对外联接和内联接的结合，也不是这样。去除括号可能会更改结果。

含嵌套外联接的查询按含内联接的查询的相同的管道方式执行。更确切地说，利用了嵌套环联接算法。让我们回忆嵌套环联接执行查询时采用什么算法。

假定我们有一个如下形式的表T1、T2、T3的联接查询：

```sql

SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3).

```

这里，**P1(T1,T2)**和**P2(T3,T3)**是一些联接条件(表达式)，其中**P(t1,t2,t3)**是表**T1、T2、T3**的列的一个条件。

嵌套环联接算法将按下面的方式执行该查询：

```sql

	FOR each row t1 in T1 {
	  FOR each row t2 in T2 such that P1(t1,t2) {
	    FOR each row t3 in T3 such that P2(t2,t3) {
	      IF P(t1,t2,t3) {
	         t:=t1||t2||t3; OUTPUT t;
	      }
	    }
	  }
	}

```

符号**t1||t2||t3**表示“连接行**t1、t2**和**t3**的列组成的行”。在下面的一些例子中，出现行名的NULL表示NULL用于行的每个列。例如，**t1||t2||NULL**表示“连接行**t1**和**t2**的列以及**t3**的每个列的**NULL**组成的行”。

现在让我们考虑带嵌套的外联接的查询：

```sql

	SELECT * FROM T1 LEFT JOIN
	              (T2 LEFT JOIN T3 ON P2(T2,T3))
	              ON P1(T1,T2)
	  WHERE P(T1,T2,T3)。

```
对于该查询我们修改嵌套环模式可以得到：

```sql

	FOR each row t1 in T1 {
	  BOOL f1:=FALSE;
	  FOR each row t2 in T2 such that P1(t1,t2) {
	    BOOL f2:=FALSE;
	    FOR each row t3 in T3 such that P2(t2,t3) {
	      IF P(t1,t2,t3) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f2=TRUE;
	      f1=TRUE;
	    }
	    IF (!f2) {
	      IF P(t1,t2,NULL) {
	        t:=t1||t2||NULL; OUTPUT t;
	      }
	      f1=TRUE;
	    }
	  }
	  IF (!f1) {
	    IF P(t1,NULL,NULL) {
	      t:=t1||NULL||NULL; OUTPUT t;
	    }
	  }
	}

```

总的来说，对于外联接操作中的第一个内表的嵌套环，引入了一个标志，在环之前关闭并且在环之后打开。如果对于外部表的当前行，如果匹配表示内操作数的表，则标志打开。如果在循环结尾处标志仍然关闭，则对于外部表的当前行，没有发现匹配。在这种情况下，对于内表的列，应使用NULL值补充行。结果行被传递到输出进行最终检查或传递到下一个嵌套环，但只能在行满足所有嵌入式外联接的联接条件时。

在我们的例子中，嵌入了下面表达式表示的外联接表：

```sql

(T2 LEFT JOIN T3 ON P2(T2,T3))

```

请注意对于有内联接的查询，优化器可以选择不同的嵌套环顺序，例如：

```sql

	FOR each row t3 in T3 {
	  FOR each row t2 in T2 such that P2(t2,t3) {
	    FOR each row t1 in T1 such that P1(t1,t2) {
	      IF P(t1,t2,t3) {
	         t:=t1||t2||t3; OUTPUT t;
	      }
	    }
	  }
	}

```

对于有外联接的查询，优化器可以只选择这样的顺序：外表的环优先于内表的环。这样，对于有外联接的查询，只可能有一种嵌套顺序。在下面的查询中，优化器将评估两个不同的嵌套：

```sql

	SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
	  WHERE P(T1,T2,T3)

```

嵌套为：

```sql

	FOR each row t1 in T1 {
	  BOOL f1:=FALSE;
	  FOR each row t2 in T2 such that P1(t1,t2) {
	    FOR each row t3 in T3 such that P2(t1,t3) {
	      IF P(t1,t2,t3) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f1:=TRUE
	    }
	  }
	  IF (!f1) {
	    IF P(t1,NULL,NULL) {
	      t:=t1||NULL||NULL; OUTPUT t;
	    }
	  }
	}

```

和

```sql

	FOR each row t1 in T1 {
	  BOOL f1:=FALSE;
	  FOR each row t3 in T3 such that P2(t1,t3) {
	    FOR each row t2 in T2 such that P1(t1,t2) {
	      IF P(t1,t2,t3) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f1:=TRUE
	    }
	  }
	  IF (!f1) {
	    IF P(t1,NULL,NULL) {
	      t:=t1||NULL||NULL; OUTPUT t;
	    }
	  }
	}

```

在两个嵌套中，必须在外环中处理**T1**，因为它用于外联接中。**T2**和**T3**用于内联接中，因此联接必须在内环中处理。但是，因为该联接是一个内联接，**T2**和**T3**可以以任何顺序处理。

当讨论内联接嵌套环的算法时，我们忽略了部分详情，可能对查询执行的性能的影响会很大。我们没有提及所谓的“下推”条件。假定可以用连接公式表示我们的**WHERE**条件**P(T1,T2,T3)**：

```sql

P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3)。

```

在这种情况下，MySQL实际使用了下面的嵌套环方案来执行带内联接得到查询：

```sql
	
	FOR each row t1 in T1 such that C1(t1) {
	  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
	    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
	      IF P(t1,t2,t3) {
	         t:=t1||t2||t3; OUTPUT t;
	      }
	    }
	  }
	}

```

你会看见每个连接 **C1(T1)，C2(T2)，C3(T3)**被从最内部的环内推出到可以对它进行评估的最外的环中。如果**C1(T1)**是一个限制性很强的条件，下推条件可以大大降低从表**T1**传递到内环的行数。结果是查询大大加速。

对于有外联接的查询，只有查出外表的当前的行可以匹配内表后，才可以检查WHERE条件。这样，对内嵌套环下推的条件不能直接用于带外联接的查询。这里我们必须引入有条件下推前提，由遇到匹配后打开的标志保护。

对于带下面的外联接的例子

```sql

P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)

```

使用受保护的下推条件的嵌套环方案看起来应为：

```sql
	
	FOR each row t1 in T1 such that C1(t1) {
	  BOOL f1:=FALSE;
	  FOR each row t2 in T2
	      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
	    BOOL f2:=FALSE;
	    FOR each row t3 in T3
	        such that P2(t2,t3) AND (f1&&f2?C3(t3):TRUE) {
	      IF (f1&&f2?TRUE:(C2(t2) AND C3(t3))) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f2=TRUE;
	      f1=TRUE;
	    }
	    IF (!f2) {
	      IF (f1?TRUE:C2(t2) && P(t1,t2,NULL)) {
	        t:=t1||t2||NULL; OUTPUT t;
	      }
	      f1=TRUE;
	    }
	  }
	  IF (!f1 && P(t1,NULL,NULL)) {
	      t:=t1||NULL||NULL; OUTPUT t;
	  }
	}

```

总的来说，可以从联接条件（例如**P1(T1,T2)**和**P(T2,T3)**）提取下推前提。在这种情况下，下推前提也受一个标志保护，防止检查由相应外联接操作所产生的NULL-补充的行的断言。

请注意如果从判断式的**WHERE**条件推导出，根据从一个内表到相同嵌套联接的另一个表的关键字进行的访问被禁止。(在这种情况下，我们可以使用有条件关键字访问，但是该技术还未用于MySQL 5.6中）。

#### 8.2.1.12.简化外连接

在许多情况下，一个查询的**FROM**子句的表的表达式可以简化。

在分析阶段，带右外联接操作的查询被转换为只包含左联接操作的等效查询。总的来说，根据以下原则进行转换：

```sql
	
	(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
	(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)

```

所有**T1 INNER JOIN T2 ON P(T1,T2)**形式的内联接表达式被替换为**T1,T2、P(T1,T2)**，并根据**WHERE**条件(或嵌入连接的联接条件，如果有)联接为一个连接。

当优化器为用外联接操作的联接查询评估方案时，它只考虑在访问内表之前访问外表的操作的方案。优化器选项受到限制，因为只有这样的方案允许我们用嵌套环机制执行带外联接操作的查询。

假定我们有一个下列形式的查询：

```sql
	
	SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
	
	  WHERE P(T1,T2) AND R(T2)

```

**R(T2)**大大减少了表**T2**中匹配的行数。如果我们这样执行查询，优化器将不会有其它选择，只能在访问表**T2**之前访问表**T1**，从而导致执行方案非常低。

幸运的是，如果**WHERE**条件拒绝**null**，MySQL可以将此类查询转换为没有外联接操作的查询。如果为该操作构建的**NULL**补充的行评估为**FALSE**或**UNKNOWN**，则该条件称为对于某个外联接操作拒绝null。

因此，对于该外联接：

```sql
	
	T1 LEFT JOIN T2 ON T1.A=T2.A

```

类似下面的条件为拒绝null：

```sql
	
	T2.B IS NOT NULL,
	T2.B > 3,
	T2.C <= T1.C,
	T2.B < 2 OR T2.C > 1
 
```

类似下面的条件不为拒绝null：

```sql
	
	T2.B IS NULL,
	T1.B < 3 OR T2.B IS NOT NULL,
	T1.B < 3 OR T2.B > 3

```

检查一个外联接操作的条件是否拒绝null的总原则很简单。以下情况下为拒绝null的条件：

* 形式为**A IS NOT NULL**，其中**A**是任何内表的一个属性

* 包含内表引用的判断式，当某个参量为**NULL**时评估为**UNKNOWN**

* 包含用于连接的拒绝**null**的条件的联合

* 拒绝**null**的条件的逻辑和

一个条件可以对于一个查询中的一个外联接操作为拒绝null的而对于另一个不为拒绝null的。在下面的查询中：

```sql

	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 LEFT JOIN T3 ON T3.B=T1.B
	
	  WHERE T3.C > 0

```

**WHERE**条件对于第2个外联接操作为拒绝null的但对于第1个不为拒绝null的。

如果**WHERE**条件对于一个查询中的一个外联接操作为拒绝null的，外联接操作被一个内联接操作代替。

例如，前面的查询被下面的查询代替：

```
	
	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 INNER JOIN T3 ON T3.B=T1.B
	
	  WHERE T3.C > 0
```

对于原来的查询，优化器将评估只与一个访问顺序**T1、T2、T3**兼容的方案。在替换的查询中，还考虑了访问顺序**T3、T1、T2**。

一个外联接操作的转化可以触发另一个的转化。这样，查询：

```sql
	
	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 LEFT JOIN T3 ON T3.B=T2.B
	
	  WHERE T3.C > 0

```

将首先转换为查询：

```sql
	
	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 INNER JOIN T3 ON T3.B=T2.B
	
	  WHERE T3.C > 0
 
```

该查询等效于查询：

```sql

	SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
	
	  WHERE T3.C > 0 AND T3.B=T2.B

```

现在剩余的外联接操作也可以被一个内联接替换，因为条件**T3.B=T2.B**为拒绝null的，我们可以得到一个根本没有外联接的查询：

```sql

	SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
	
	  WHERE T3.C > 0 AND T3.B=T2.B

```

有时我们可以成功替换嵌入的外联接操作，但不能转换嵌入的外联接。下面的查询：

```sql
	
	SELECT * FROM T1 LEFT JOIN
	
	              (T2 LEFT JOIN T3 ON T3.B=T2.B)
	
	              ON T2.A=T1.A
	
	  WHERE T3.C > 0

```

被转换为：

```sql

	SELECT * FROM T1 LEFT JOIN
	
	              (T2 INNER JOIN T3 ON T3.B=T2.B)
	
	              ON T2.A=T1.A
	
	  WHERE T3.C > 0，

```

只能重新写为仍然包含嵌入式外联接操作的形式：

```sql

	SELECT * FROM T1 LEFT JOIN
	
	              (T2,T3)
	
	              ON (T2.A=T1.A AND T3.B=T2.B)
	
	  WHERE T3.C > 0。

```

如果试图转换一个查询中的嵌入式外联接操作，我们必须考虑嵌入式外联接的联接条件和**WHERE**条件。在下面的查询中：

```sql

	SELECT * FROM T1 LEFT JOIN
	              (T2 LEFT JOIN T3 ON T3.B=T2.B)
	              ON T2.A=T1.A AND T3.C=T1.C
	  WHERE T3.D > 0 OR T1.D > 0

```

**WHERE**条件对于嵌入式外联接不为拒绝null的，但嵌入式外联接**T2.A=T1.A AND T3.C=T1.C**的联接条件为拒绝null的。因此该查询可以转换为：

```sql

	SELECT * FROM T1 LEFT JOIN
	
	              (T2, T3)
	
	              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
	
	  WHERE T3.D > 0 OR T1.D > 0

```

#### 8.2.1.13.多范围读优化












899  8.2.1.12

[SELECT]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md
[UNION]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md#13.02.09.04
[index]:./docs/术语表
[joins]:./docs/术语表
[foreign keyss]:./docs/术语表
[EXPLAIN]:./docs/Chapter_13/13.08.02_EXPLAIN_Syntax.md
[8.3.1]:./docs/Chapter_08/8.03.1_How_MySQL_Uses_Indexes.md
[8.8.1]:./docs/Chapter_08/8.08.1_Optimizing_Queries_with_EXPLAIN.md
[full table scans]:.docs/术语表
[ANALYZE TABLE]:./docs/Chapter_13/13.7.2_Table_Maintenance_Statements.md#13.7.2.1
[8.5.5]:./docs/Chapter_08/8.05.5_Optimizing_InnoDB_Queries.md
[章节14.2.4.2.3，“为只读事务优化”]:./docs/Chapter_14/14.02.4_InnoDB_Performance_Tuning_and_Troubleshooting.md#14.02.4.2#14.02.4.2.03
[buffer pool]:./docs/术语表
[958]:
[8.2.1.3.1节，“单元素索引的范围访问方法”]:
[range]:
[index_merge]:
[eq\_range\_index\_dive\_limit]:
[NDB]:./docs/Chapter_17/17.00.00_MySQL_Cluster_NDB7.3.md
[12.5.1]:./docs/Chapter_12/12.05.01_String_Comparison_Functions.md
[11.4.3]:./docs/Chapter_11/11.04.03_The_BLOB_and_TEXT_Types.md
[8.8.5.2]:./docs/Chapter_08/08.08.05_Controlling_the_Query_Optimizer.md#08.08.05.02
[InnoDB]:./docs/Chapter_14/14.02.00_The_InnoDB_Storage_Engine.md
[8.2.1.14]：./docs/Chapter_08/08.02.01_Optimizing_SELECT_Statements.md#08.02.01.14
[13.2.9.2]:./docs/13.02.09_JOIN_Syntax.md#13.02.09.02

备注：1.在一张表进行COUNT(*)[1303][] 这里还没有连接，因为是关于页数连接的。
2.（例如COUNT(*)[1303][],MIN()[1305][]等）这里还没有连接，因为是关于页数连接的
3.#### 8.2.1.3.范围优化 下面的range还没有连接
4.dive未翻译
5.pushdown翻译成叠加？
6.**range**,**ref**,**eq_ref**和**ref_or_null**连接到    
  8.8.2.EXPALIN EXTENDED
7.optimizer_switch 连接到5.1.4.Server System Variables

orc扫描到936页