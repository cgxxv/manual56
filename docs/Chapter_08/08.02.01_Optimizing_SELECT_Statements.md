### 8.2.1.优化 SELECT 语句
以 [SELECT][SELECT] 语句形式的查询执行数据库所有的查找。调优这些语句是首先要做的事情，不管是获得动态网页的 子秒（sub-second）效应时间，还是砍掉数小时的来生成一整晚的报告。

#### [8.2.1.1.SELECT 语句的速度](#8.2.1.1)
优化查询主要考虑如下这几点：

* 要想一个慢速 SELECT ... WHERE 查询更快，第一件事是检查你能不能添加一个[索引][index]。在字段建立索引并在WHERE子句使用，来加速评估、过滤和最后结果的检索。构建一个小的能加速很多相关查询的索引集合应用于你的程序来避免浪费磁盘的空间。

	索引对于涉及几个表的查询特别重要，而这些表使用了例如[joins][joins]和[foreign keyss][foreign keyss]的特性。你可以使用[EXPLAIN][EXPLAIN]语句来确定哪些索引用于一个[SELECT][SELECT]语句。看[8.3.1章节，“MySQL怎样使用索引”][8.3.1]和[8.8.1章节“用EXPLAIN优化查询”][8.8.1]。

* 隔离和调整查询的部分，例如一个花费过多时间的函数调用。取决于查询是怎样构造的，一个函数或者会被结果集的每一行调用一次，或者甚至被表的每一行调用一次。极大地把效率低放大了。

* 在你的查询最小化[全表扫描][full table scans]的数量，特别是大表。

* 定期地使用[ANALYZE TABLE][ANALYZE TABLE]   语句来使表保持最新的统计,这样优化器有了需要去构造一个有效的执行计划的信息。

* 学习针对每张表存储引擎的调优技巧，索引技巧和配置参数。InnoDB和MyISAM两个存储引擎都有很多能使查询成为和维持高性能的指导方针。更详细的信息，查阅[章节8.5.5，“优化InnoDB查询”][8.5.5]和[章节8.6.1,“优化MyISAM查询”][8.6.1]。

* 特别地，在MySQL5.6.4和更高的版本，你可以使用[章节14.2.4.2.3，“为只读事务优化”][章节14.2.4.2.3，“为只读事务优化”]的技巧为InnoDB表优化单一查询的事务。

* 避免用令查询变得很难理解的方式来改变它们，特别是如果优化器自动地做一些相同的改变。

* 如果一个性能问题不容易被基本的指导方针解决，可以通过查看[EXPLAIN][EXPLAIN]计划和调整你的索引、WHERE子句、join子句等等。（当你获得了一定的专业知识后，查看EXPLAIN计划可能是你优化每一次查询的第一步）

* 调整MySQL用来做缓存的内存区域的大小和属性。随着InnoDB[缓冲池][buffer pool]、MyISAM关键字缓存和MySQL查询缓存的有效使用，重复的查询会变得更快，因为结果可以从内存二次和后续时间重新得到。

* 即使对于一个使用了内存区域而运行得很快的查询，你还是需要优化得更好，以便它们需要更少的缓存内存，使你的应用程序更容易扩展。扩展意味着你的应用程序能处理更多的用户同时访问、更大的请求等等而不会令到性能有一个很大的下降。

* 当你的查询速度会被其他同时访问同一张表的会话影响时，就要处理锁定问题。

#### [8.2.1.2.MySQL优化 WHERE 子句的原理](#8.2.1.2)

这个章节将会讨论能用于处理 WHERE 子句的优化。使用SELECT语句的例子，同样适用优化使用了DELETE和UPDATE语句的WHERE子句。 

	Note：因为在MySQL优化器调试的工作还在进行，不是所有MySQL执行的优化都会出现在文档这里。

你可能会被诱惑重写你的查询令到它们算法操作更快，而牺牲可读性。因为MySQL会自动地做相同的优化，所以你可以经常避免这种工作和让查询保持更容易理解和可持续的形式。一些由MySQL执行的优化如下：

* 去掉不需要的括号：
```sql
	((a AND b) AND c OR (((a AND b ) AND (c AND d))))
    ->(a AND b AND c ) OR (a AND b AND c AND d)
```

* 常量合并
```sql
	(a<b AND b=c) AND a=5
    b>5 AND b=c AND a=5 
```

* 移除常量条件（必须的，因为常量可以合并）
```sql
	(B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
	->B=5 OR B=6
```

* 被索引使用的常量表达式只被计算一次。

* 在一张表进行COUNT(*)[1303][]操作而没有使用 WHERE 时对于 MyISAM 和 MEMORY 表是可以直接从表信息取到的.对于在一张表使用任何的 NOT NULL 语句也是一样的。

* 非法常量表达式的早期检测。MySQL会快速检测一些无效的[SELECT][SELECT]语句和不会返回记录。

* 如果你没有使用 GROUP BY 或者聚合函数（例如COUNT(*)[1303][],MIN()[1305][]等），HAVING 和 WHERE 混合使用。

* 对于一个连接的每一张表，一个更简单的 WHERE 被构造来获得一个更快的 WHERE 估算而且会尽可能地跳过无关的行。

* 在查询中所有的静态表会比其他任何表先进行读。符合以下任何一种情况都可认为是一张静态表：

	* 一张空表或者只有一行的表。
	
	* 一张在主键和唯一索引上面使用了一个 WHERE 子句的表，而该表的所有索引都被比作常量表达式和被定义成非空。

	所有如下的表都被视为静态表：

	```sql
	SELECT * FROM t WHERE primary_key=1;
	SELECT * FROM t1,t2
		WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
	```
* 对于表的连接的最好连接组合是通过尝试所有的可能性来发现的。如果在ORDER BY和GROUP BY子句的所有列都来自同一张表，那么该表在连接的时候将会是优先的。

* 如果在一个连接队列里面有一个ORDER BY子句和一个不同的GROUP BY子句，或者如果ORDER BY或GROUP BY包含的列来自几张表，而这些表不同于第一张表，就会创建一张临时表。

* 如果你使用了 SQL_SMALL_RESULT 选项，MySQL会使用一张存在于内存的临时表。

* 每张表的所以都会被查询，而且最好的索引会被使用，除非优化器相信进行全表扫描更有效。同时，全表扫描是否会进行取决于最好的索引是否跨越了表的30%的范围，但是一个固定的比例不再决定选择使用索引还是全表扫描。现在的优化器变得更复杂和基于它对额外的因素(例如表的大小、行数和I/O块的大小)的衡量。

* 在一些情况下，MySQL能从索引读取行而不需要查询数据文件。如果索引所使用的列都是数值，那么只要使用索引树就可以解决查询了。

* 在每一行输出之前，那些没有匹配HAVING子句的行将会被忽略。

一些查询的例子是非常快的：
```sql
SELECT COUNT(*) FROM tb1_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tb1_name;

SELECT MAX(key_part2) FROM tb1_name
  WHERE key_part1=constant;

SELECT ... FROM tb1_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tb1_name
  ORDER BY key_part1 DESC, key_part2 DESC,... LIMIT10;
```

下列查询MySQL仅使用索引树就可以解决(假设索引的列为数值型)：

```sql
SELECT key_part1, key_part2 FROM tb1_name WHERE key_part1=val;

SELECT COUNT(*) FROM tb1_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tb1_name GROUP BY key_part1;
```
下列查询使用索引按排序顺序检索行，不用另外的排序：
```sql
SELECT ... FROM tb1_name
  ORDER BY key_part1, key_part2,... ;

SELECT ... FROM tb1_name
  ORDER BY key_part1 DESC, key_part2 DESC, ...;
```

#### [8.2.1.3.范围优化](#8.2.1.3)

[range][958]访问方法使用单一索引来搜索包含在一个或几个索引值距离内的表记录的子集。可以用于单部分或多元素索引。后面的章节将详细描述如何从WHERE子句提取区间。

##### 8.2.1.3.1.单元素索引的范围访问方法

对于单元素索引，可以用WHERE子句中的相应条件很方便地表示索引值区间，因此我们称为范围条件而不是“区间”。
单元素索引范围条件的定义如下：

* 对于BTREE和HASH索引，当使用=、<=>、IN、IS NULL或者IS NOT NULL操作符时，关键元素与常量值的比较关系对应一个范围条件。

* 对于BTREE索引，当使用>、<、>=、<=、BETWEEN、!=或者<>，或者LIKE 'pattern'(其中 'pattern'不以通配符开始)操作符时，关键元素与常量值的比较关系对应一个范围条件。

* 对于所有类型的索引，多个范围条件结合OR或AND则产生一个范围条件。

   前面描述的“常量值”系指：

* 查询字符串中的常量

* 同一联接中的const或system表中的列

* 无关联子查询的结果

* 完全从前面类型的子表达式组成的表达式

下面是一些WHERE子句中有范围条件的查询的例子：
```sql
SELECT * FROM t1 
    WHERE key_col > 1 
    AND key_col < 10;
 
SELECT * FROM t1 
    WHERE key_col = 1 
    OR key_col IN (15,18,20);
 
SELECT * FROM t1 
    WHERE key_col LIKE 'ab%' 
    OR key_col BETWEEN 'bar' AND 'foo';
```
请注意在常量传播阶段部分非常量值可以转换为常数。

MySQL尝试为每个可能的索引从WHERE子句提取范围条件。在提取过程中，不能用于构成范围条件的条件被放弃，产生重叠范围的条件组合到一起，并且产生空范围的条件被删除。

例如，考虑下面的语句，其中key1是有索引的列，nonkey没有索引：
```sql
SELECT * FROM t1 WHERE
   (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
   (key1 < 'bar' AND nonkey = 4) OR
   (key1 < 'uux' AND key1 > 'z');
```
key1的提取过程如下:

1. 用原始WHERE子句开始：
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```
2. 删除nonkey = 4和key1 LIKE '%b'，因为它们不能用于范围扫描。删除它们的正确途径是用TRUE替换它们，以便进行范围扫描时不会丢失匹配的记录。用TRUE替换它们后，可以得到：
```sql
 (key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1 < 'uux' AND key1 > 'z')
```
3.取消总是为true或false的条件：

* (key1 LIKE 'abcde%' OR TRUE)总是true

* (key1 < 'uux' AND key1 > 'z')总是false 

用常量替换这些条件，我们得到：
```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```
删除不必要的TRUE和FALSE常量，我们得到:
```sql
(key1 < 'abc') OR (key1 < 'bar')
```
4. 将重叠区间组合成一个产生用于范围扫描的最终条件:
```sql
(key1 < 'bar')
```
总的来说(如前面的例子所述)，用于范围扫描的条件比WHERE子句限制少。MySQL再执行检查以过滤掉满足范围条件但不完全满足WHERE子句的行。

范围条件提取算法可以处理嵌套的任意深度的AND/OR结构，并且其输出不依赖条件在WHERE子句中出现的顺序。

现在，MySQL已经对空间索引的range访问方法不再支持合并多范围了。为了适应这种限制，你可以在同一个 [SELECT][SELECT] 语句里使用一个 [UNION][UNION] ，除非你将每一个空间谓词放到了不同的 SELECT 语句。

##### 8.2.1.3.2.多元素索引的范围访问方法

多元素索引的范围条件是单元素索引的范围条件的扩展。多元素索引的范围条件将索引记录限制到一个或几个关键元组内。使用索引的顺序，通过一系列关键元组来定义关键元组区间。

例如，考虑定义为key1(key_part1, key_part2, key_part3)的多元素索引，以及下面的按关键字顺序所列的关键元组：
```sql
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
```
条件key_part1 = 1定义了下面的范围：
```sql
(1，-inf，-inf) <= (key_part1，key_part2，key_part3) < (1，+inf，+inf)
```
范围包括前面数据集中的第4、5和6个元组，可以用于范围访问方法。

通过对比，条件key_part3 = 'abc'不定义单一的区间，不能用于范围访问方法。

下面更加详细地描述了范围条件如何用于多元素索引中。






考虑下面这些表达式， col_name 是一个索引列:
```sql
col_name IN(val1, ..., valN )
col_name = val1 OR ... OR col_name = valN
```
如果 col_name 和这些值中的一个相等，那么该表达式就为true。



882

[SELECT]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md
[UNION]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md#13.02.09.04
[index]:./docs/术语表
[joins]:./docs/术语表
[foreign keyss]:./docs/术语表
[EXPLAIN]:./docs/Chapter_13/13.8.2_EXPLAIN_Syntax.md
[8.3.1]:./docs/Chapter_08/8.03.1_How_MySQL_Uses_Indexes.md
[8.8.1]:./docs/Chapter_08/8.08.1_Optimizing_Queries_with_EXPLAIN.md
[full table scans]:.docs/术语表
[ANALYZE TABLE]:./docs/Chapter_13/13.7.2_Table_Maintenance_Statements.md#13.7.2.1
[8.5.5]:./docs/Chapter_08/8.05.5_Optimizing_InnoDB_Queries.md
[章节14.2.4.2.3，“为只读事务优化”]:./docs/Chapter_14/14.02.4_InnoDB_Performance_Tuning_and_Troubleshooting.md#14.02.4.2#14.02.4.2.03
[buffer pool]:./docs/术语表
[958]:

备注：1.在一张表进行COUNT(*)[1303][] 这里还没有连接，因为是关于页数连接的。
2.（例如COUNT(*)[1303][],MIN()[1305][]等）这里还没有连接，因为是关于页数连接的
3.#### 8.2.1.3.范围优化 下面的range还没有连接