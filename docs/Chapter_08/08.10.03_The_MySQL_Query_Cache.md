### 8.10.3 The MySQL Query Cache

The query cache stores the text of a [SELECT][49] statement together with the corresponding result that was sent to the client. If an identical statement is received later, the server retrieves the results from the query cache rather than parsing and executing the statement again. The query cache is shared among sessions, so a result set generated by one client can be sent in response to the same query issued by another client.

The query cache can be useful in an environment where you have tables that do not change very often and for which the server receives many identical queries. This is a typical situation for many Web servers that generate many dynamic pages based on database content.

The query cache does not return stale data. When tables are modified, any relevant entries in the query cache are flushed.

Note

The query cache does not work in an environment where you have multiple [mysqld][50] servers updating the sameMyISAM tables.

The query cache is used for prepared statements under the conditions described in [Section 8.10.3.1, “How the Query Cache Operates”][51].

Note

As of MySQL 5.6.5, the query cache is not supported for partitioned tables, and is automatically disabled for queries involving partitioned tables. The query cache cannot be enabled for such queries. (Bug #53775)

Some performance data for the query cache follows. These results were generated by running the MySQL benchmark suite on a Linux Alpha 2×500MHz system with 2GB RAM and a 64MB query cache.

*   If all the queries you are performing are simple (such as selecting a row from a table with one row), but still differ so that the queries cannot be cached, the overhead for having the query cache active is 13%. This could be regarded as the worst case scenario. In real life, queries tend to be much more complicated, so the overhead normally is significantly lower.

*   Searches for a single row in a single-row table are 238% faster with the query cache than without it. This can be regarded as close to the minimum speedup to be expected for a query that is cached.

To disable the query cache at server startup, set the [query_cache_size][52] system variable to 0\. By disabling the query cache code, there is no noticeable overhead.

The query cache offers the potential for substantial performance improvement, but do not assume that it will do so under all circumstances. With some query cache configurations or server workloads, you might actually see a performance decrease:

*   Be cautious about sizing the query cache excessively large, which increases the overhead required to maintain the cache, possibly beyond the benefit of enabling it. Sizes in tens of megabytes are usually beneficial. Sizes in the hundreds of megabytes might not be.

*   Server workload has a significant effect on query cache efficiency. A query mix consisting almost entirely of a fixed set of [SELECT][35] statements is much more likely to benefit from enabling the cache than a mix in which frequent[INSERT][36] statements cause continual invalidation of results in the cache. In some cases, a workaround is to use theSQL_NO_CACHE option to prevent results from even entering the cache for [SELECT][37] statements that use frequently modified tables. (See [Section 8.10.3.2, “Query Cache SELECT Options”][38].)

To verify that enabling the query cache is beneficial, test the operation of your MySQL server with the cache enabled and disabled. Then retest periodically because query cache efficiency may change as server workload changes.

#### 8.10.3.1 How the Query Cache Operates

### 

This section describes how the query cache works when it is operational. [Section 8.10.3.3, “Query Cache Configuration”][53], describes how to control whether it is operational.

Incoming queries are compared to those in the query cache before parsing, so the following two queries are regarded as different by the query cache:

```
SELECT * FROM tbl_name
Select * from tbl_name
```

The cache is not used for queries of the following types:

*   Queries that are a subquery of an outer query

*   Queries executed within the body of a stored function, trigger, or event

Before a query result is fetched from the query cache, MySQL checks whether the user has [SELECT][54] privilege for all databases and tables involved. If this is not the case, the cached result is not used.

If a query result is returned from query cache, the server increments the [Qcache_hits][55] status variable, not Com_select. See [Section 8.10.3.4, “Query Cache Status and Maintenance”][56].

If a table changes, all cached queries that use the table become invalid and are removed from the cache. This includes queries that use MERGE tables that map to the changed table. A table can be changed by many types of statements, such as [INSERT][57], [UPDATE][58], [DELETE][59], [TRUNCATE TABLE][60], [ALTER TABLE][61], [DROP TABLE][62], or [DROP DATABASE][63].

The query cache also works within transactions when using InnoDB tables.

The result from a [SELECT][64] query on a view is cached.

The query cache works for SELECT SQL_CALC_FOUND_ROWS ... queries and stores a value that is returned by a following SELECT FOUND_ROWS() query. [FOUND_ROWS()][65] returns the correct value even if the preceding query was fetched from the cache because the number of found rows is also stored in the cache. The SELECT FOUND_ROWS()query itself cannot be cached.

Prepared statements that are issued using the binary protocol using [mysql_stmt_prepare()][66] and[mysql_stmt_execute()][67] (see [Section 23.8.8, “C API Prepared Statements”][68]), are subject to limitations on caching. Comparison with statements in the query cache is based on the text of the statement after expansion of ? parameter markers. The statement is compared only with other cached statements that were executed using the binary protocol. That is, for query cache purposes, prepared statements issued using the binary protocol are distinct from prepared statements issued using the text protocol (see [Section 13.5, “Prepared SQL Statement Syntax”][69]).

A query cannot be cached if it contains any of the functions shown in the following table.

<colgroup><col><col><col></colgroup>
| [`BENCHMARK()`][1] | [`CONNECTION_ID()`][2] | [`CONVERT_TZ()`][3] |
| [`CURDATE()`][4] | [`CURRENT_DATE()`][5] | [`CURRENT_TIME()`][6] |
| [`CURRENT_TIMESTAMP()`][7] | [`CURRENT_USER()`][8] | [`CURTIME()`][9] |
| [`DATABASE()`][10] | [`ENCRYPT()`][11] with one parameter | [`FOUND_ROWS()`][12] |
| [`GET_LOCK()`][13] | [`IS_FREE_LOCK()`][14] | [`IS_USED_LOCK()`][15] |
| [`LAST_INSERT_ID()`][16] | [`LOAD_FILE()`][17] | [`MASTER_POS_WAIT()`][18] |
| [`NOW()`][19] | [`PASSWORD()`][20] | [`RAND()`][21] |
| [`RANDOM_BYTES()`][22] | [`RELEASE_ALL_LOCKS()`][23] | [`RELEASE_LOCK()`][24] |
| [`SLEEP()`][25] | [`SYSDATE()`][26] | [`UNIX_TIMESTAMP()`][27] with no parameters |
| [`USER()`][28] | [`UUID()`][29] | [`UUID_SHORT()`][30] |

A query also is not cached under these conditions:

*   It refers to user-defined functions (UDFs) or stored functions.

*   It refers to user variables or local stored program variables.

*   It refers to tables in the mysql, INFORMATION_SCHEMA, or performance_schema database.

*   (MySQL 5.6.5 and later:) It refers to any partitioned tables.

*   It is of any of the following forms:SELECT ... LOCK IN SHARE MODE SELECT ... FOR UPDATE SELECT ... INTO OUTFILE ... SELECT ... INTO DUMPFILE ... SELECT * FROM ... WHERE autoincrement_col IS NULL The last form is not cached because it is used as the ODBC workaround for obtaining the last insert ID value. See the Connector/ODBC section of [Chapter 23, Connectors and APIs][39].Statements within transactions that use [SERIALIZABLE][40] isolation level also cannot be cached because they use LOCK IN SHARE MODE locking.

*   It uses TEMPORARY tables.

*   It does not use any tables.

*   It generates warnings.

*   The user has a column-level privilege for any of the involved tables.

#### 8.10.3.2 Query Cache SELECT Options

### 

Two query cache-related options may be specified in [SELECT][70] statements:

*   SQL_CACHEThe query result is cached if it is cacheable and the value of the [query_cache_type][41] system variable is ON orDEMAND.

*   SQL_NO_CACHEThe server does not use the query cache. It neither checks the query cache to see whether the result is already cached, nor does it cache the query result. (Due to a limitation in the parser, a space character must precede and follow the SQL_NO_CACHE keyword; a nonspace such as a newline causes the server to check the query cache to see whether the result is already cached.)

Examples:

```
SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
```

#### 8.10.3.3 Query Cache Configuration

### 

The [have_query_cache][71] server system variable indicates whether the query cache is available:

```
mysql> SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
```

Several other system variables control query cache operation. These can be set in an option file or on the command line when starting [mysqld][72]. The query cache system variables all have names that begin with query_cache_. They are described briefly in [Section 5.1.5, “Server System Variables”][73], with additional configuration information given here.

To set the size of the query cache, set the [query_cache_size][74] system variable. Setting it to 0 disables the query cache, as does setting [query_cache_type=0][75]. By default, the query cache is disabled. This is achieved using a default size of 1M, with a default for query_cache_type of 0\. (Before MySQL 5.6.8, the default size is 0, with a default query_cache_type of 1.)

To reduce overhead significantly, start the server with [query_cache_type=0][76] if you will not be using the query cache.

Note

When using the Windows Configuration Wizard to install or configure MySQL, the default value for[query_cache_size][77] will be configured automatically for you based on the different configuration types available. When using the Windows Configuration Wizard, the query cache may be enabled (that is, set to a nonzero value) due to the selected configuration. The query cache is also controlled by the setting of the [query_cache_type][78]variable. Check the values of these variables as set in your my.ini file after configuration has taken place.

When you set [query_cache_size][79] to a nonzero value, keep in mind that the query cache needs a minimum size of about 40KB to allocate its structures. (The exact size depends on system architecture.) If you set the value too small, you'll get a warning, as in this example:

```
mysql> SET GLOBAL query_cache_size = 40000;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> SHOW WARNINGS\G
*************************** 1\. row ***************************
  Level: Warning
   Code: 1282
Message: Query cache failed to set size 39936;
         new query cache size is 0

mysql> SET GLOBAL query_cache_size = 41984;
Query OK, 0 rows affected (0.00 sec)

mysql> SHOW VARIABLES LIKE 'query_cache_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_size | 41984 |
+------------------+-------+
```

```
mysql> SET GLOBAL query_cache_size = 1000000;
Query OK, 0 rows affected (0.04 sec)

mysql> SHOW VARIABLES LIKE 'query_cache_size';
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| query_cache_size | 999424 |
+------------------+--------+
1 row in set (0.00 sec)
```

If the query cache size is greater than 0, the [query_cache_type][80] variable influences how it works. This variable can be set to the following values:

*   A value of 0 or OFF prevents caching or retrieval of cached results.

*   A value of 1 or ON enables caching except of those statements that begin with SELECT SQL_NO_CACHE.

*   A value of 2 or DEMAND causes caching of only those statements that begin with SELECT SQL_CACHE.

If [query_cache_size][81] is 0, you should also set [query_cache_type][82] variable to 0\. In this case, the server does not acquire the query cache mutex at all, which means that the query cache cannot be enabled at runtime and there is reduced overhead in query execution.

Setting the GLOBAL [query_cache_type][83] value determines query cache behavior for all clients that connect after the change is made. Individual clients can control cache behavior for their own connection by setting the SESSION[query_cache_type][84] value. For example, a client can disable use of the query cache for its own queries like this:

```
mysql> SET SESSION query_cache_type = OFF;
```

To control the maximum size of individual query results that can be cached, set the [query_cache_limit][85] system variable. The default value is 1MB.

Be careful not to set the size of the cache too large. Due to the need for threads to lock the cache during updates, you may see lock contention issues with a very large cache.

Note

You can set the maximum size that can be specified for the query cache at runtime with the [SET][86] statement by using the --maximum-query_cache_size=32M option on the command line or in the configuration file.

When a query is to be cached, its result (the data sent to the client) is stored in the query cache during result retrieval. Therefore the data usually is not handled in one big chunk. The query cache allocates blocks for storing this data on demand, so when one block is filled, a new block is allocated. Because memory allocation operation is costly (timewise), the query cache allocates blocks with a minimum size given by the [query_cache_min_res_unit][87]system variable. When a query is executed, the last result block is trimmed to the actual data size so that unused memory is freed. Depending on the types of queries your server executes, you might find it helpful to tune the value of [query_cache_min_res_unit][88]:

*   The default value of [query_cache_min_res_unit][42] is 4KB. This should be adequate for most cases.

*   If you have a lot of queries with small results, the default block size may lead to memory fragmentation, as indicated by a large number of free blocks. Fragmentation can force the query cache to prune (delete) queries from the cache due to lack of memory. In this case, decrease the value of [query_cache_min_res_unit][43]. The number of free blocks and queries removed due to pruning are given by the values of the [Qcache_free_blocks][44] and[Qcache_lowmem_prunes][45] status variables.

*   If most of your queries have large results (check the [Qcache_total_blocks][46] and [Qcache_queries_in_cache][47]status variables), you can increase performance by increasing [query_cache_min_res_unit][48]. However, be careful to not make it too large (see the previous item).

#### 8.10.3.4 Query Cache Status and Maintenance

### 

To check whether the query cache is present in your MySQL server, use the following statement:

```
mysql> SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
```

The RESET QUERY CACHE statement removes all query results from the query cache. The [FLUSH TABLES][89]statement also does this.

To monitor query cache performance, use [SHOW STATUS][90] to view the cache status variables:

```
mysql> SHOW STATUS LIKE 'Qcache%';
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Qcache_free_blocks      | 36     |
| Qcache_free_memory      | 138488 |
| Qcache_hits             | 79570  |
| Qcache_inserts          | 27087  |
| Qcache_lowmem_prunes    | 3114   |
| Qcache_not_cached       | 22989  |
| Qcache_queries_in_cache | 415    |
| Qcache_total_blocks     | 912    |
+-------------------------+--------+
```

The total number of [SELECT][91] queries is given by this formula:

```
  Com_select
+ Qcache_hits
+ queries with errors found by parser
```

```
  Qcache_inserts
+ Qcache_not_cached
+ queries with errors found during the column-privileges check
```

Every cached query requires a minimum of two blocks (one for the query text and one or more for the query results). Also, every table that is used by a query requires one block. However, if two or more queries use the same table, only one table block needs to be allocated.

The information provided by the [Qcache_lowmem_prunes][92] status variable can help you tune the query cache size. It counts the number of queries that have been removed from the cache to free up memory for caching new queries. The query cache uses a least recently used (LRU) strategy to decide which queries to remove from the cache. Tuning information is given in [Section 8.10.3.3, “Query Cache Configuration”][93].

[1]:functions.html#function_benchmark
[2]:functions.html#function_connection-id
[3]:functions.html#function_convert-tz
[4]:functions.html#function_curdate
[5]:functions.html#function_current-date
[6]:functions.html#function_current-time
[7]:functions.html#function_current-timestamp
[8]:functions.html#function_current-user
[9]:functions.html#function_curtime
[10]:functions.html#function_database
[11]:functions.html#function_encrypt
[12]:functions.html#function_found-rows
[13]:functions.html#function_get-lock
[14]:functions.html#function_is-free-lock
[15]:functions.html#function_is-used-lock
[16]:functions.html#function_last-insert-id
[17]:functions.html#function_load-file
[18]:functions.html#function_master-pos-wait
[19]:functions.html#function_now
[20]:functions.html#function_password
[21]:functions.html#function_rand
[22]:functions.html#function_random-bytes
[23]:http://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_release-all-locks
[24]:functions.html#function_release-lock
[25]:functions.html#function_sleep
[26]:functions.html#function_sysdate
[27]:functions.html#function_unix-timestamp
[28]:functions.html#function_user
[29]:functions.html#function_uuid
[30]:functions.html#function_uuid-short
[31]:optimization.html#query-cache-operation
[32]:optimization.html#query-cache-in-select
[33]:optimization.html#query-cache-configuration
[34]:optimization.html#query-cache-status-and-maintenance
[35]:sql-syntax.html#select
[36]:sql-syntax.html#insert
[37]:sql-syntax.html#select
[38]:optimization.html#query-cache-in-select
[39]:connectors-apis.html
[40]:innodb-storage-engine.html#isolevel_serializable
[41]:server-administration.html#sysvar_query_cache_type
[42]:server-administration.html#sysvar_query_cache_min_res_unit
[43]:server-administration.html#sysvar_query_cache_min_res_unit
[44]:server-administration.html#statvar_Qcache_free_blocks
[45]:server-administration.html#statvar_Qcache_lowmem_prunes
[46]:server-administration.html#statvar_Qcache_total_blocks
[47]:server-administration.html#statvar_Qcache_queries_in_cache
[48]:server-administration.html#sysvar_query_cache_min_res_unit
[49]:sql-syntax.html#select
[50]:programs.html#mysqld
[51]:optimization.html#query-cache-operation
[52]:server-administration.html#sysvar_query_cache_size
[53]:optimization.html#query-cache-configuration
[54]:sql-syntax.html#select
[55]:server-administration.html#statvar_Qcache_hits
[56]:optimization.html#query-cache-status-and-maintenance
[57]:sql-syntax.html#insert
[58]:sql-syntax.html#update
[59]:sql-syntax.html#delete
[60]:sql-syntax.html#truncate-table
[61]:sql-syntax.html#alter-table
[62]:sql-syntax.html#drop-table
[63]:sql-syntax.html#drop-database
[64]:sql-syntax.html#select
[65]:functions.html#function_found-rows
[66]:connectors-apis.html#mysql-stmt-prepare
[67]:connectors-apis.html#mysql-stmt-execute
[68]:connectors-apis.html#c-api-prepared-statements
[69]:sql-syntax.html#sql-syntax-prepared-statements
[70]:sql-syntax.html#select
[71]:server-administration.html#sysvar_have_query_cache
[72]:programs.html#mysqld
[73]:server-administration.html#server-system-variables
[74]:server-administration.html#sysvar_query_cache_size
[75]:server-administration.html#sysvar_query_cache_type
[76]:server-administration.html#sysvar_query_cache_type
[77]:server-administration.html#sysvar_query_cache_size
[78]:server-administration.html#sysvar_query_cache_type
[79]:server-administration.html#sysvar_query_cache_size
[80]:server-administration.html#sysvar_query_cache_type
[81]:server-administration.html#sysvar_query_cache_size
[82]:server-administration.html#sysvar_query_cache_type
[83]:server-administration.html#sysvar_query_cache_type
[84]:server-administration.html#sysvar_query_cache_type
[85]:server-administration.html#sysvar_query_cache_limit
[86]:sql-syntax.html#set-variable
[87]:server-administration.html#sysvar_query_cache_min_res_unit
[88]:server-administration.html#sysvar_query_cache_min_res_unit
[89]:sql-syntax.html#flush
[90]:sql-syntax.html#show-status
[91]:sql-syntax.html#select
[92]:server-administration.html#statvar_Qcache_lowmem_prunes
[93]:optimization.html#query-cache-configuration