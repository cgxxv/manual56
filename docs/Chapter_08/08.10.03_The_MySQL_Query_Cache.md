### 8.10.3. The MySQL Query Cache

The query cache stores the text of a [SELECT](TODO) statement together with the corresponding result that was sent to the client. If an identical statement is received later, the server retrieves the results from the query cache rather than parsing and executing the statement again. The query cache is shared among sessions, so a result set generated by one client can be sent in response to the same query issued by another client.

The query cache can be useful in an environment where you have tables that do not change very often and for which the server receives many identical queries. This is a typical situation for many Web servers that generate many dynamic pages based on database content.

The query cache does not return stale data. When tables are modified, any relevant entries in the query cache are flushed.

> Note
> 
> The query cache does not work in an environment where you have multiple [mysqld](TODO) > servers updating the same [MyISAM](NONE) tables.

The query cache is used for prepared statements under the conditions described in [Section 8.10.3.1, “How the Query Cache Operates”](8.10.3.1).


> Note
> 
> As of MySQL 5.6.5, the query cache is not supported for partitioned tables, and is automatically disabled for queries involving partitioned tables. The query cache cannot be enabled for such queries. (Bug #53775)

Some performance data for the query cache follows. These results were generated by running the MySQL benchmark suite on a Linux Alpha 2×500MHz system with 2GB RAM and a 64MB query cache.

- If all the queries you are performing are simple (such as selecting a row from a table with one row), but still differ so that the queries cannot be cached, the overhead for having the query cache active is 13%. This could be regarded as the worst case scenario. In real life, queries tend to be much more complicated, so the overhead normally is significantly lower.

- Searches for a single row in a single-row table are 238% faster with the query cache than without it. This can be regarded as close to the minimum speedup to be expected for a query that is cached.

To disable the query cache at server startup, set the [query_cache_size](TODO) system variable to 0. By disabling the query cache code, there is no noticeable overhead.

The query cache offers the potential for substantial performance improvement, but do not assume that it will do so under all circumstances. With some query cache configurations or server workloads, you might actually see a performance decrease:

- Be cautious about sizing the query cache excessively large, which increases the overhead required to maintain the cache, possibly beyond the benefit of enabling it. Sizes in tens of megabytes are usually beneficial. Sizes in the hundreds of megabytes might not be.

- Server workload has a significant effect on query cache efficiency. A query mix consisting almost entirely of a fixed set of [SELECT](TODO) statements is much more likely to benefit from enabling the cache than a mix in which frequent INSERT statements cause continual invalidation of results in the cache. In some cases, a workaround is to use the [SQL_NO_CACHE](TODO) option to prevent results from even entering the cache for [SELECT](TODO) statements that use frequently modified tables. (See [Section 8.10.3.2, “Query Cache SELECT Options”](8.10.3.2).)

To verify that enabling the query cache is beneficial, test the operation of your MySQL server with the cache enabled and disabled. Then retest periodically because query cache efficiency may change as server workload changes.

#### 8.10.3.1 How the Query Cache Operates

This section describes how the query cache works when it is operational. [Section 8.10.3.3, “Query Cache Configuration”](8.10.3.3), describes how to control whether it is operational.

Incoming queries are compared to those in the query cache before parsing, so the following two queries are regarded as different by the query cache:

    SELECT * FROM tbl_name
    Select * from tbl_name

Queries must be exactly the same (byte for byte) to be seen as identical. In addition, query strings that are identical may be treated as different for other reasons. Queries that use different databases, different protocol versions, or different default character sets are considered different queries and are cached separately.

The cache is not used for queries of the following types:

- Queries that are a subquery of an outer query

- Queries executed within the body of a stored function, trigger, or event

Before a query result is fetched from the query cache, MySQL checks whether the user has SELECT privilege for all databases and tables involved. If this is not the case, the cached result is not used.

If a query result is returned from query cache, the server increments the [Qcache_hits](TODO) status variable, not [Com_select](NONE). See [Section 8.10.3.4, “Query Cache Status and Maintenance”](8.10.3.4).

If a table changes, all cached queries that use the table become invalid and are removed from the cache. This includes queries that use [MERGE](NONE) tables that map to the changed table. A table can be changed by many types of statements, such as [INSERT](TODO), [UPDATE](TODO), [DELETE](TODO), [TRUNCATE TABLE](TODO), [ALTER TABLE](TODO), [DROP TABLE](TODO), or [DROP DATABASE](TODO).

The query cache also works within transactions when using [InnoDB](NONE) tables.

The result from a [SELECT](TODO) query on a view is cached.

The query cache works for [SELECT SQL_CALC_FOUND_ROWS](NONE) ... queries and stores a value that is returned by a following [SELECT FOUND_ROWS()](NONE) query. [FOUND_ROWS()](TODO) returns the correct value even if the preceding query was fetched from the cache because the number of found rows is also stored in the cache. The SELECT [FOUND_ROWS()](NONE) query itself cannot be cached.

Prepared statements that are issued using the binary protocol using [mysql_stmt_prepare()](TODO) and [mysql_stmt_execute()](TODO) (see [Section 23.8.8, “C API Prepared Statements”](23.8.8)), are subject to limitations on caching. Comparison with statements in the query cache is based on the text of the statement after expansion of ? parameter markers. The statement is compared only with other cached statements that were executed using the binary protocol. That is, for query cache purposes, prepared statements issued using the binary protocol are distinct from prepared statements issued using the text protocol (see [Section 13.5, “Prepared SQL Statement Syntax”](13.5)).

A query cannot be cached if it contains any of the functions shown in the following table.

    BENCHMARK()	CONNECTION_ID()	CONVERT_TZ()
    CURDATE()	CURRENT_DATE()	CURRENT_TIME()
    CURRENT_TIMESTAMP()	CURRENT_USER()	CURTIME()
    DATABASE()	ENCRYPT() with one parameter	FOUND_ROWS()
    GET_LOCK()	IS_FREE_LOCK()	IS_USED_LOCK()
    LAST_INSERT_ID()	LOAD_FILE()	MASTER_POS_WAIT()
    NOW()	PASSWORD()	RAND()
    RANDOM_BYTES()	RELEASE_ALL_LOCKS()	RELEASE_LOCK()
    SLEEP()	SYSDATE()	UNIX_TIMESTAMP() with no parameters
    USER()	UUID()	UUID_SHORT()

A query also is not cached under these conditions:

- It refers to user-defined functions (UDFs) or stored functions.

- It refers to user variables or local stored program variables.

- It refers to tables in the mysql, INFORMATION_SCHEMA, or performance_schema database.

- (MySQL 5.6.5 and later:) It refers to any partitioned tables.

- It is of any of the following forms:

    SELECT ... LOCK IN SHARE MODE
    SELECT ... FOR UPDATE
    SELECT ... INTO OUTFILE ...
    SELECT ... INTO DUMPFILE ...
    SELECT * FROM ... WHERE autoincrement_col IS NULL

The last form is not cached because it is used as the ODBC workaround for obtaining the last insert ID value. See the Connector/ODBC [section of Chapter 23, Connectors and APIs](23).

Statements within transactions that use [SERIALIZABLE](TODO) isolation level also cannot be cached because they use [LOCK IN SHARE MODE](NONE) locking.

- It uses TEMPORARY tables.

- It does not use any tables.

- It generates warnings.

- The user has a column-level privilege for any of the involved tables.

#### 8.10.3.2 Query Cache SELECT Options

Two query cache-related options may be specified in SELECT statements:

- [SQL_CACHE](NONE)

The query result is cached if it is cacheable and the value of the [query_cache_type](TODO) system variable is [ON](NONE) or [DEMAND](NONE).

- SQL_NO_CACHE

The server does not use the query cache. It neither checks the query cache to see whether the result is already cached, nor does it cache the query result. (Due to a limitation in the parser, a space character must precede and follow the [SQL_NO_CACHE](NONE) keyword; a nonspace such as a newline causes the server to check the query cache to see whether the result is already cached.)

Examples:

    SELECT SQL_CACHE id, name FROM customer;
    SELECT SQL_NO_CACHE id, name FROM customer;

#### 8.10.3.3 Query Cache Configuration

The [have_query_cache](TODO) server system variable indicates whether the query cache is available:

    mysql> SHOW VARIABLES LIKE 'have_query_cache';
    +------------------+-------+
    | Variable_name    | Value |
    +------------------+-------+
    | have_query_cache | YES   |
    +------------------+-------+

When using a standard MySQL binary, this value is always [YES](NONE), even if query caching is disabled.

Several other system variables control query cache operation. These can be set in an option file or on the command line when starting [mysqld](TODO). The query cache system variables all have names that begin with [query_cache_](NONE). They are described briefly in [Section 5.1.5, “Server System Variables”](5.1.5), with additional configuration information given here.

To set the size of the query cache, set the [query_cache_size](TODO) system variable. Setting it to 0 disables the query cache, as does setting [query_cache_type=0](TODO). By default, the query cache is disabled. This is achieved using a default size of 1M, with a default for [query_cache_type](NONE) of 0. (Before MySQL 5.6.8, the default size is 0, with a default [query_cache_type](NONE) of 1.)

To reduce overhead significantly, start the server with [query_cache_type=0](TODO) if you will not be using the query cache.

> Note
> 
> When using the Windows Configuration Wizard to install or configure MySQL, the default value for [query_cache_size](TODO) will be configured automatically for you based on the different configuration types available. When using the Windows Configuration Wizard, the query cache may be enabled (that is, set to a nonzero value) due to the selected configuration. The query cache is also controlled by the setting of the [query_cache_type](TODO) variable. Check the values of these variables as set in your [my.ini](NONE) file after configuration has taken place.

When you set [query_cache_size](TODO) to a nonzero value, keep in mind that the query cache needs a minimum size of about 40KB to allocate its structures. (The exact size depends on system architecture.) If you set the value too small, you'll get a warning, as in this example:

    mysql> SET GLOBAL query_cache_size = 40000;
    Query OK, 0 rows affected, 1 warning (0.00 sec)
    
    mysql> SHOW WARNINGS\G
    *************************** 1. row ***************************
      Level: Warning
       Code: 1282
    Message: Query cache failed to set size 39936;
             new query cache size is 0
    
    mysql> SET GLOBAL query_cache_size = 41984;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> SHOW VARIABLES LIKE 'query_cache_size';
    +------------------+-------+
    | Variable_name    | Value |
    +------------------+-------+
    | query_cache_size | 41984 |
    +------------------+-------+

For the query cache to actually be able to hold any query results, its size must be set larger:

    mysql> SET GLOBAL query_cache_size = 1000000;
    Query OK, 0 rows affected (0.04 sec)
    
    mysql> SHOW VARIABLES LIKE 'query_cache_size';
    +------------------+--------+
    | Variable_name    | Value  |
    +------------------+--------+
    | query_cache_size | 999424 |
    +------------------+--------+
    1 row in set (0.00 sec)

The [query_cache_size](TODO) value is aligned to the nearest 1024 byte block. The value reported may therefore be different from the value that you assign.

If the query cache size is greater than 0, the [query_cache_type](TODO) variable influences how it works. This variable can be set to the following values:

- A value of [0](NONE) or [OFF](NONE) prevents caching or retrieval of cached results.

- A value of [1](NONE) or [ON](NONE) enables caching except of those statements that begin with SELECT SQL_NO_CACHE.

- A value of 2 or DEMAND causes caching of only those statements that begin with [SELECT SQL_CACHE](NONE).

If [query_cache_size](TODO) is 0, you should also set [query_cache_type](TODO) variable to 0. In this case, the server does not acquire the query cache mutex at all, which means that the query cache cannot be enabled at runtime and there is reduced overhead in query execution.

Setting the GLOBAL [query_cache_type](TODO) value determines query cache behavior for all clients that connect after the change is made. Individual clients can control cache behavior for their own connection by setting the SESSION [query_cache_type](NONE) value. For example, a client can disable use of the query cache for its own queries like this:

    mysql> SET SESSION query_cache_type = OFF;

If you set [query_cache_type](TODO) at server startup (rather than at runtime with a [SET](TODO) statement), only the numeric values are permitted.

To control the maximum size of individual query results that can be cached, set the [query_cache_limit](TODO) system variable. The default value is 1MB.

Be careful not to set the size of the cache too large. Due to the need for threads to lock the cache during updates, you may see lock contention issues with a very large cache.

> Note
> 
> You can set the maximum size that can be specified for the query cache at runtime with the [SET](NONE) statement by using the [--maximum-query_cache_size=32M](NONE) option on the command line or in the configuration file.

When a query is to be cached, its result (the data sent to the client) is stored in the query cache during result retrieval. Therefore the data usually is not handled in one big chunk. The query cache allocates blocks for storing this data on demand, so when one block is filled, a new block is allocated. Because memory allocation operation is costly (timewise), the query cache allocates blocks with a minimum size given by the [query_cache_min_res_unit](TODO) system variable. When a query is executed, the last result block is trimmed to the actual data size so that unused memory is freed. Depending on the types of queries your server executes, you might find it helpful to tune the value of [query_cache_min_res_unit](TODO):

- The default value of [query_cache_min_res_unit](TODO) is 4KB. This should be adequate for most cases.

- If you have a lot of queries with small results, the default block size may lead to memory fragmentation, as indicated by a large number of free blocks. Fragmentation can force the query cache to prune (delete) queries from the cache due to lack of memory. In this case, decrease the value of [query_cache_min_res_unit](TODO). The number of free blocks and queries removed due to pruning are given by the values of the [Qcache_free_blocks](TODO) and [Qcache_lowmem_prunes](TODO) status variables.

- If most of your queries have large results (check the Qcache_total_blocks and Qcache_queries_in_cache status variables), you can increase performance by increasing query_cache_min_res_unit. However, be careful to not make it too large (see the previous item).

#### 8.10.3.4 Query Cache Status and Maintenance

To check whether the query cache is present in your MySQL server, use the following statement:

    mysql> SHOW VARIABLES LIKE 'have_query_cache';
    +------------------+-------+
    | Variable_name    | Value |
    +------------------+-------+
    | have_query_cache | YES   |
    +------------------+-------+

You can defragment the query cache to better utilize its memory with the [FLUSH QUERY CACHE](TODO) statement. The statement does not remove any queries from the cache.

The [RESET QUERY CACHE](NONE) statement removes all query results from the query cache. The [FLUSH TABLES](TODO) statement also does this.

To monitor query cache performance, use [SHOW STATUS](TODO) to view the cache status variables:

    mysql> SHOW STATUS LIKE 'Qcache%';
    +-------------------------+--------+
    | Variable_name           | Value  |
    +-------------------------+--------+
    | Qcache_free_blocks      | 36     |
    | Qcache_free_memory      | 138488 |
    | Qcache_hits             | 79570  |
    | Qcache_inserts          | 27087  |
    | Qcache_lowmem_prunes    | 3114   |
    | Qcache_not_cached       | 22989  |
    | Qcache_queries_in_cache | 415    |
    | Qcache_total_blocks     | 912    |
    +-------------------------+--------+

Descriptions of each of these variables are given in [Section 5.1.7, “Server Status Variables”](5.1.7). Some uses for them are described here.

The total number of SELECT queries is given by this formula:
    
      Com_select
    + Qcache_hits
    + queries with errors found by parser

The Com_select value is given by this formula:

      Qcache_inserts
    + Qcache_not_cached
    + queries with errors found during the column-privileges check

The query cache uses variable-length blocks, so [Qcache_total_blocks](TODO) and [Qcache_free_blocks](TODO) may indicate query cache memory fragmentation. After [FLUSH QUERY CACHE](TODO), only a single free block remains.

Every cached query requires a minimum of two blocks (one for the query text and one or more for the query results). Also, every table that is used by a query requires one block. However, if two or more queries use the same table, only one table block needs to be allocated.

The information provided by the [Qcache_lowmem_prunes](TODO) status variable can help you tune the query cache size. It counts the number of queries that have been removed from the cache to free up memory for caching new queries. The query cache uses a least recently used (LRU) strategy to decide which queries to remove from the cache. Tuning information is given in [Section 8.10.3.3, “Query Cache Configuration”](8.10.3.3).