### 8.11.1 Internal Locking Methods

This section discusses internal locking; that is, locking performed within the MySQL server itself to manage contention for table contents by multiple sessions. This type of locking is internal because it is performed entirely by the server and involves no other programs. For locking performed on MySQL files by other programs, see [Section 8.11.5, “External Locking”][8].

#### Row-Level Locking

MySQL uses [row-level locking][9] for InnoDB tables to support simultaneous write access by multiple sessions, making them suitable for multi-user, highly concurrent, and OLTP applications.

To avoid [deadlocks][10] when performing multiple concurrent write operations on a single InnoDB table, acquire necessary locks at the start of the transaction by issuing a SELECT ... FOR UPDATE statement for each group of rows expected to be modified, even if the data change statements come later in the transaction. If transactions modify or lock more than one table, issue the applicable statements in the same order within each transaction. Deadlocks affect performance rather than representing a serious error, because InnoDB automatically [detects][11]deadlock conditions and rolls back one of the affected transactions.

Advantages of row-level locking:

*   Fewer lock conflicts when different sessions access different rows.

*   Fewer changes for rollbacks.

*   Possible to lock a single row for a long time.

#### Table-Level Locking

MySQL uses [table-level locking][12] for MyISAM, MEMORY, and MERGE tables, permitting only one session to update those tables at a time. This locking level makes these storage engines more suitable for read-only, read-mostly, or single-user applications.

These storage engines avoid [deadlocks][13] by always requesting all needed locks at once at the beginning of a query and always locking the tables in the same order. The tradeoff is that this strategy reduces concurrency; other sessions that want to modify the table must wait until the current data change statement finishes.

Advantages of table-level locking:

*   Relatively little memory required (row locking requires memory per row or group of rows locked)

*   Fast when used on a large part of the table because only a single lock is involved.

*   Fast if you often do GROUP BY operations on a large part of the data or must scan the entire table frequently.

MySQL grants table write locks as follows:

1.  If there are no locks on the table, put a write lock on it.

2.  Otherwise, put the lock request in the write lock queue.

MySQL grants table read locks as follows:

1.  If there are no write locks on the table, put a read lock on it.

2.  Otherwise, put the lock request in the read lock queue.

Table updates are given higher priority than table retrievals. Therefore, when a lock is released, the lock is made available to the requests in the write lock queue and then to the requests in the read lock queue. This ensures that updates to a table are not “starved” even when there is heavy [SELECT][14] activity for the table. However, if there are many updates for a table, [SELECT][15] statements wait until there are no more updates.

For information on altering the priority of reads and writes, see [Section 8.11.2, “Table Locking Issues”][16].

You can analyze the table lock contention on your system by checking the [Table_locks_immediate][17] and[Table_locks_waited][18] status variables, which indicate the number of times that requests for table locks could be granted immediately and the number that had to wait, respectively:

```
mysql> SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
```

The MyISAM storage engine supports concurrent inserts to reduce contention between readers and writers for a given table: If a MyISAM table has no free blocks in the middle of the data file, rows are always inserted at the end of the data file. In this case, you can freely mix concurrent [INSERT][19] and [SELECT][20] statements for a MyISAM table without locks. That is, you can insert rows into a MyISAM table at the same time other clients are reading from it. Holes can result from rows having been deleted from or updated in the middle of the table. If there are holes, concurrent inserts are disabled but are enabled again automatically when all holes have been filled with new data. To control this behavior, use the [concurrent_insert][21] system variable. See [Section 8.11.3, “Concurrent Inserts”][22].

If you acquire a table lock explicitly with [LOCK TABLES][23], you can request a READ LOCAL lock rather than a READ lock to enable other sessions to perform concurrent inserts while you have the table locked.

To perform many [INSERT][24] and [SELECT][25] operations on a table t1 when concurrent inserts are not possible, you can insert rows into a temporary table temp_t1 and update the real table with the rows from the temporary table:

```
mysql> LOCK TABLES t1 WRITE, temp_t1 WRITE;
mysql> INSERT INTO t1 SELECT * FROM temp_t1;
mysql> DELETE FROM temp_t1;
mysql> UNLOCK TABLES;
```

Generally, table locks are superior to row-level locks in the following cases:

*   Most statements for the table are reads.

*   Statements for the table are a mix of reads and writes, where writes are updates or deletes for a single row that can be fetched with one key read:UPDATE tbl_name SET column=value WHERE unique_key_col=key_value; DELETE FROM tbl_name WHERE unique_key_col=key_value;

*   [SELECT][1] combined with concurrent [INSERT][2] statements, and very few [UPDATE][3] or [DELETE][4] statements.

*   Many scans or GROUP BY operations on the entire table without any writers.

With higher-level locks, you can more easily tune applications by supporting locks of different types, because the lock overhead is less than for row-level locks.

Options other than row-level locking:

<a></a>

*   Versioning (such as that used in MySQL for concurrent inserts) where it is possible to have one writer at the same time as many readers. This means that the database or table supports different views for the data depending on when access begins. Other common terms for this are “time travel,” “copy on write,” or “copy on demand.”

*   Copy on demand is in many cases superior to row-level locking. However, in the worst case, it can use much more memory than using normal locks.

*   Instead of using row-level locks, you can employ application-level locks, such as those provided by [GET_LOCK()][5]and [RELEASE_LOCK()][6] in MySQL. These are advisory locks, so they work only with applications that cooperate with each other. See [Section 12.19, “Miscellaneous Functions”][7].

[1]:sql-syntax.html#select
[2]:sql-syntax.html#insert
[3]:sql-syntax.html#update
[4]:sql-syntax.html#delete
[5]:functions.html#function_get-lock
[6]:functions.html#function_release-lock
[7]:functions.html#miscellaneous-functions
[8]:optimization.html#external-locking
[9]:glossary.html#glos_row_lock
[10]:glossary.html#glos_deadlock
[11]:glossary.html#glos_deadlock_detection
[12]:glossary.html#glos_table_lock
[13]:glossary.html#glos_deadlock
[14]:sql-syntax.html#select
[15]:sql-syntax.html#select
[16]:optimization.html#table-locking
[17]:server-administration.html#statvar_Table_locks_immediate
[18]:server-administration.html#statvar_Table_locks_waited
[19]:sql-syntax.html#insert
[20]:sql-syntax.html#select
[21]:server-administration.html#sysvar_concurrent_insert
[22]:optimization.html#concurrent-inserts
[23]:sql-syntax.html#lock-tables
[24]:sql-syntax.html#insert
[25]:sql-syntax.html#select