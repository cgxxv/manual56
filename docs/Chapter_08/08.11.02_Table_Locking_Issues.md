### 8.11.2 Table Locking Issues

InnoDB tables use row-level locking so that multiple sessions and applications can read from and write to the same table simultaneously, without making each other wait or producing inconsistent results. For this storage engine, avoid using the [LOCK TABLES][34] statement, because it does not offer any extra protection, but instead reduces concurrency. The automatic row-level locking makes these tables suitable for your busiest databases with your most important data, while also simplifying application logic since you do not need to lock and unlock tables. Consequently, the InnoDB storage engine is the default in MySQL.

MySQL uses table locking (instead of page, row, or column locking) for all storage engines except InnoDB. The locking operations themselves do not have much overhead. But because only one session can write to a table at any one time, for best performance with these other storage engines, use them primarily for tables that are queried often and rarely inserted into or updated.

#### Performance Considerations Favoring InnoDB

When choosing whether to create a table using InnoDB or a different storage engine, keep in mind the following disadvantages of table locking:

*   Table locking enables many sessions to read from a table at the same time, but if a session wants to write to a table, it must first get exclusive access, meaning it might have to wait for other sessions to finish with the table first. During the update, all other sessions that want to access this particular table must wait until the update is done.

*   Table locking causes problems when a session is waiting because the disk is full and free space needs to become available before the session can proceed. In this case, all sessions that want to access the problem table are also put in a waiting state until more disk space is made available.

*   A [SELECT][1] statement that takes a long time to run prevents other sessions from updating the table in the meantime, making the other sessions appear slow or unresponsive. While a session is waiting to get exclusive access to the table for updates, other sessions that issue [SELECT][2] statements will queue up behind it, reducing concurrency even for read-only sessions.

#### Workarounds for Locking Performance Issues

The following items describe some ways to avoid or reduce contention caused by table locking:

*   Consider switching the table to the InnoDB storage engine, either using CREATE TABLE ... ENGINE=INNODBduring setup, or using ALTER TABLE ... ENGINE=INNODB for an existing table. See [Chapter 14, The InnoDB Storage Engine][3] for more details about this storage engine.

*   Optimize [SELECT][4] statements to run faster so that they lock tables for a shorter time. You might have to create some summary tables to do this.

*   Start [mysqld][5] with [--low-priority-updates][6]. For storage engines that use only table-level locking (such asMyISAM, MEMORY, and MERGE), this gives all statements that update (modify) a table lower priority than [SELECT][7]statements. In this case, the second [SELECT][8] statement in the preceding scenario would execute before the [UPDATE][9]statement, and would not wait for the first [SELECT][10] to finish.

*   To specify that all updates issued in a specific connection should be done with low priority, set the[low_priority_updates][11] server system variable equal to 1.

*   To give a specific [INSERT][12], [UPDATE][13], or [DELETE][14] statement lower priority, use the LOW_PRIORITY attribute.

*   To give a specific [SELECT][15] statement higher priority, use the HIGH_PRIORITY attribute. See [Section 13.2.9, “SELECT Syntax”][16].

*   Start [mysqld][17] with a low value for the [max_write_lock_count][18] system variable to force MySQL to temporarily elevate the priority of all [SELECT][19] statements that are waiting for a table after a specific number of inserts to the table occur. This permits READ locks after a certain number of WRITE locks.

*   If you have problems with [INSERT][20] combined with [SELECT][21], consider switching to MyISAM tables, which support concurrent [SELECT][22] and [INSERT][23] statements. (See [Section 8.11.3, “Concurrent Inserts”][24].)

*   If you mix inserts and deletes on the same nontransactional table, [INSERT DELAYED][25] may help. See [Section 13.2.5.2, “INSERT DELAYED Syntax”][26].NoteAs of MySQL 5.6.6, [INSERT DELAYED][27] is deprecated, and will be removed in a future release. Use INSERT (withoutDELAYED) instead.

*   If you have problems with mixed [SELECT][28] and [DELETE][29] statements, the LIMIT option to [DELETE][30] may help. See[Section 13.2.2, “DELETE Syntax”][31].

*   Using SQL_BUFFER_RESULT with [SELECT][32] statements can help to make the duration of table locks shorter. See[Section 13.2.9, “SELECT Syntax”][33].

*   Splitting table contents into separate tables may help, by allowing queries to run against columns in one table, while updates are confined to columns in a different table.

*   You could change the locking code in mysys/thr_lock.c to use a single queue. In this case, write locks and read locks would have the same priority, which might help some applications.

[1]:sql-syntax.html#select
[2]:sql-syntax.html#select
[3]:innodb-storage-engine.html
[4]:sql-syntax.html#select
[5]:programs.html#mysqld
[6]:server-administration.html#option_mysqld_low-priority-updates
[7]:sql-syntax.html#select
[8]:sql-syntax.html#select
[9]:sql-syntax.html#update
[10]:sql-syntax.html#select
[11]:server-administration.html#sysvar_low_priority_updates
[12]:sql-syntax.html#insert
[13]:sql-syntax.html#update
[14]:sql-syntax.html#delete
[15]:sql-syntax.html#select
[16]:sql-syntax.html#select
[17]:programs.html#mysqld
[18]:server-administration.html#sysvar_max_write_lock_count
[19]:sql-syntax.html#select
[20]:sql-syntax.html#insert
[21]:sql-syntax.html#select
[22]:sql-syntax.html#select
[23]:sql-syntax.html#insert
[24]:optimization.html#concurrent-inserts
[25]:sql-syntax.html#insert-delayed
[26]:sql-syntax.html#insert-delayed
[27]:sql-syntax.html#insert-delayed
[28]:sql-syntax.html#select
[29]:sql-syntax.html#delete
[30]:sql-syntax.html#delete
[31]:sql-syntax.html#delete
[32]:sql-syntax.html#select
[33]:sql-syntax.html#select
[34]:sql-syntax.html#lock-tables