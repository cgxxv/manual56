### 19.3.1. 触发器语法和示例

创建或删除触发器, 使用[CREATE TRIGGER](../Chapter_13/13.01.19_CREATE_TRIGGER_Syntax.md)或[DROP TRIGGER](../Chapter_13/13.01.30_DROP_TRIGGER_Syntax.md)语句, 详细描述请参阅[章节13.1.19, “创建触发器语法”](../Chapter_13/../Chapter_13/13.01.19_CREATE_TRIGGER_Syntax.md)和[章节13.1.30, “删除触发器语法”](../Chapter_13/13.01.30_DROP_TRIGGER_Syntax.md).

这里是一个简单的示例, 它关联一个触发器到一张表, [INSERT](../Chapter_13/13.02.05_INSERT_Syntax.md)操作时触发器激活. 
该触发器扮演了一个累加器的角色, 将插入到该表中一个自动的值进行累加. 

    mysql> CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));
    	Query OK, 0 rows affected (0.03 sec)
    mysql> CREATE TRIGGER ins_sum BEFORE INSERT ON account
    	-> FOR EACH ROW SET @sum = @sum + NEW.amount;
    	Query OK, 0 rows affected (0.06 sec)

示例中, [CREATE TRIGGER](../Chapter_13/13.01.19_CREATE_TRIGGER_Syntax.md)语句创建了一个名为`ins_sum`的触发器, 该触发器与`account`表关联. 该语句还包含了描述触发器的执行时间, 触发事件, 以及触发器的激活行为的语句: 

* `BEFORE`关键字指明了触发器的执行时间. 在这种情况下, 触发器在每个记录行插入到表之前激活. 另一个允许的关键字是`AFTER`. 
* `INSERT`关键字指明了触发事件. 也即, 该类型的操作将激活触发器. 在示例中, [INSERT](../Chapter_13/13.02.05_INSERT_Syntax.md)操作将导致触发器激活. 同样, 可以创建[DELETE](../Chapter_13/13.02.02_DELETE_Syntax.md)和[UPDATE](../Chapter_13/13.02.11_UPDATE_Syntax.md)操作的触发器.
* 在`FOR EACH ROW`之后的语句定义了触发器的主体; 该定义为, 在每一次触发器激活时执行该语句, 当每一个记录行被触发事件影响到时该执行动作发生. 比如说, 该触发器主体是一个简单的[SET](../Chapter_13/13.07.04_SET_Syntax.md)语句. 将新插入到`amount`列的值累加并[SET](../Chapter_13/13.07.04_SET_Syntax.md)到用户变量中. 该语句使用`NEW.amount`作列引用, 其意为”即将插入的新记录行的`amount`列的值”. 

使用该触发器, 设置累加变量的值为0, 执行一个[INSERT](../Chapter_13/13.02.05_INSERT_Syntax.md)语句, 然后查看一下该变量的值.

    mysql> SET @sum = 0;
    mysql> INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);
    mysql> SELECT @sum AS 'Total amount inserted';
    +-----------------------+
    | Total amount inserted |
    +-----------------------+
    | 1852.48   |
    +-----------------------+ 

在本例中, 执行[INSERT](../Chapter_13/13.02.05_INSERT_Syntax.md)语句后, `@sum`的值为`14.98 + 1937.50 -100`, 即`1852.48`. 
销毁该触发器, 使用[DROP TRIGGER](../Chapter_13/13.01.30_DROP_TRIGGER_Syntax.md)语句. 若该触发器不属于默认的数据库, 必须指明数据库名, 如下:
 
    mysql> DROP TRIGGER test.ins_sum;

如果删除一张表, 关于该表的任何触发器都将被删除. 

触发器的名称存在于数据库的命名空间, 这意味着某个数据库下的所有触发器都必须使用唯一的命名. 不同数据库下的触发器, 则可以使用相同的命名. 

在一个数据库下, 触发器除了命名唯一这样的必要条件, 对于触发器的创建类型, 还有一些其它的限制. 特别地, 对于同一张表, 不能存在触发事件和执行时间相同的多个触发器. 比如说, 不能对同一张表创建两个`BEFORE UPDATE`触发器. 对于这种工作场景, 可以在`FOR EACH ROW`之后, 使用[BEGIN...END](../Chapter_13/13.06.01_BEGIN...END_Compound-Statement_Syntax.md)复合语句构建一个执行多语句的触发器. (请见本章节随后的示例). 

在触发器的主体内部, 可以使用关键字`OLD`和`NEW`来访问受触发器所影响记录行的列.
`OLD`和`NEW`是MySQL对于触发器的扩展; 其不区分大小写. 

对于`INSERT`触发器, 只有`NEW.col_name`可用; 没有旧记录行可用. 对于`DELETE`触发器, 只有`OLD.col_name`可用; 没有新记录行可用. 对于`UPDATE`触发器, 可以使用`OLD.col_name`来引用被更新前的记录行的列, 也可以使用`NEW.col_name`来引用被更新后的记录行的列. 

使用基于`OLD`命名的列为只读属性. 可以对其引用(需具备`SELECT`权限), 但不能修改. 
如果有`SELECT`权限, 可以对使用基于`NEW`命名的列进行引用. 对于`BEFORE`触发器, 除了可以引用, 还可以使用`SET NEW.col_name = value`对其进行更改(需具备`UPDATE`权限). 
这意味着, 可以使用触发器修改即将插入的新记录行或者用于更新记录行. 
(这样的`SET`语句对于`AFTER`触发器无效, 因为记录行已被改变了.)

在`BEFORE`类型的触发器中, 自增(`AUTO_INCREMENT`)列的新(`NEW`)值为0, 并非在新记录行实际插入时的序列生成数值.

使用[BEGIN...END](../Chapter_13/13.06.01_BEGIN...END_Compound-Statement_Syntax.md)结构定义触发器时, 可以在其中执行多个语句. 在`BEGIN`块中, 还可以使用存储程序中允许使用的其它语法结构, 比如: 条件运算和循环. 但是, 和存储程序一样, 如果使用[mysql](../Chapter_4/04.05.01_mysql — The MySQL Command-Line Tool.md)程序定义包含执行多个语句的触发器, 需要重定义mysql语句分隔符`;`. 只有如此, 才能在触发器的定义语句内使用语句分隔符`;`. 如下的例子说明了这点. 它定义了一个`UPDATE`触发器, 用来检查并修改每一个更新行, 以确保被修改值的范围在0到100之内. 这必须是一个`BEFORE`触发器, 因为新值必须在经过检查之后, 才能被用于记录行的更新. 

    mysql> delimiter //
    mysql> CREATE TRIGGER upd_check BEFORE UPDATE ON account
	    -> FOR EACH ROW
	    -> BEGIN
	    -> IF NEW.amount < 0 THEN
	    -> SET NEW.amount = 0;
	    -> ELSEIF NEW.amount > 100 THEN
	    -> SET NEW.amount = 100;
	    -> END IF;
	    -> END;//
    mysql> delimiter ;

// 未完待续 @ 2603.6     -- 09.22 pm
