# 14.2.1 Getting Started with InnoDB Tables

## 14.2.1.1. InnoDB as the Default MySQL Storage Engine

MySQL有一个保证性能及可扩展性并且易于使用的名声。在之前版本的MySQL中，MyISAM是默认的储存引擎，在我们的经验里，大部分用户从来不会改变默认的储存引擎。在MySQL 5.5中，InnoDB变成了默认的储存引擎。再次重复一下，我们希望大部分用户不要修改默认设置。因为InnoDB的默认设置已经启用了用户对于RDBMS所需要的各种特性：ACID事务，参照完整性以及崩溃恢复。让我们来看一下如何使用InnoDB表才能使你的MySQL用户，DBA或者开发者的生活变得更加美好。

### Trends in Storage Engine Usage

在MySQL早期，早期的基于Web的程序并没有提出对可用性及可扩展性限制的要求。在2010年，硬件及内存性能及其性价比已经到达一个顶峰，用户开始提出对MySQL的性能进行限制来提升可靠性及崩溃恢复。MySQL已经成为了一个大的，繁忙的，健壮的，分布式的以及重要的数据库。

InnoDB接受了来自用户的顶级优先要求。储存引擎使用的趋势已经转向有更好扩展性的InnoDB。MySQL 5.5中，InnoDB顺理成章地成为默认储存引擎。

MySQL仍然在为解决以前需要使用MyISAM表的用户用例工作着，在MySQL 5.6或者更高版本中：

* InnoDB可以通过使用FULLTEXT索引来执行全文搜索，参见Section 14.2.3.12.3,“FULLTEXT Indexes”。

* InnoDB目前为只读或者大部分读得工作负载优化了性能，在autocommit模型中会自动为InnoDB查询优化性能，你也可以使用START TRANSACTION READ ONLY来把事务设置为只读。参见Section 14.2.4.2.3,“Optimizations for Read-Only Transactions”

* 只读媒介上的程序现在也可以使用InnoDB表了，参见Section 14.2.5.1,“Support for Read-Only Media”

### Consequences of InnoDB as Default MySQL Storage Engine

从MySQL 5.5.5开始，新表的默认储存引擎是InnoDB。这个修正只会对新的建表时未使用ENGINE=MyISAM之类指定储存引擎的表起作用（这也表示，MySQL 5.5可能是使用InnoDB可以得到比MyISAM更多的好处的一个分水岭）。

mysql及information_schema数据库，是MySQL的内置数据库，仍然在使用MyISAM，并且，你不能把其中的表修正为使用InnoDB。

### Benefits of InnoDB Tables如果你使用过MyISAM但由于技术方面的原因放弃了，那你可以在MySQL 5.5中的InnoDB表上找到你感兴趣的东西。
* 如果你的服务器由于硬件或者软件方面的问题崩溃了，无论那个时间数据库发生了什么事，你不需要在重启数据库的时候做任何事情。InnoDB崩溃恢复会自动完成崩溃时间之前所有的已提交的修改，并且回滚所有已执行但未提交的修改。只需要重启服务器就可以了，这个过程已经比MySQL 5.1的时候快了很多。
* InnoDB缓冲池会缓存正在访问的表及索引。这样可以直接在内存中访问数据。这个缓存可以用于多种类型的数据，并极大提升执行速度，数据库服务器建议把80%的物理内存分配给InnoDB缓冲池。
* 如果你把相关的数据切分入不同的表，你可以使用外键来保证参照完整性。修改或者删除数据时，其他表的相关的数据会自动被修改或者删除。如果试图在子表中添加父表中并不存在的值，会阻止数据的插入并自动报错。
* 如果数据在内存或者磁盘上损坏了，存在一个校验机制会在你使用它之前发出一个警报。
* 当你在设计数据库的时候为每个表都设置了主键时，对那些列的操作会被自动优化。在WHERE，ORDER BY，GROUP BY及JOIN操作中，使用主键的话性能会得到大幅度提升。
* 添加，删除，修改等操作会被一个叫做变更缓存的自动机制来优化。InnoDB不仅允许同一个表的并发读与并发写，它也会缓存修改后的数据来减少磁盘I/O。
* 对性能的优化没有限制长时间的查询。当相同的行被反复访问时，一个叫做自适应哈希索引的特性会提升这些访问的速度到类似直接从哈希表中读出来一样。
### Best Practices for InnoDB Tables
如果你已经使用了很长时间的InnoDB，你已经知道事务以及外键之类的特性，如果没有，请通读这一章节。下面有一个简介：
* 为每个表都指定一个主键，这样会优化很多顺序查询，如果没有明显可用来做主键的列，可以使用auto-increment值作为主键。
* 对于join操作，也就是通过ID值来同多个表中查出数据。为了提升联接性能，在联接列上定义外键，并且保证其在所有表里面都是同一种数据类型。外键经常会级联修改或者删除多个表的数据，并且会在子表插入数据之前检测父表是否有对应数据。
* 关闭自动提交。大量提交会大量消耗时间，对性能有影响（受限于你磁盘的写入速度）。
* 把相关的DML操作放入同一个事务里，通过 START TRANSACTION 及 COMMIT语句控制来执行事务。当你不想频繁提交时，你也不需要面对需要几个小时的批处理INSETRT，UPDATE，DELETE任务。
* 不要使用LOCK TABLE语句。InnoDB允许多个会话同时访问一个表而不会影响可靠性及性能。为了对一组行做排他锁，可以执行 SELECT ... FOR UPDATE来锁定必要的行。
* 把innodb_file_per_table选项打开来把每个表的数据及索引放在独立的文件里而不是一个单独的系统表空间里。（这个设置需要其他一些特性，如表压缩及快速事务）
* 评估你的表是否适合使用InnoDB的表压缩特性。（在CREATE TABLE语句中添加ROW_FORMAT=COMPRESSED，你可以在不影响读写性能的前提下压缩表）
* 使用 --sql_mode=NO_ENGINE_SUBSTITUTION选项来运行你的数据库，这样会阻止你使用其他的储存引擎，即使指定 ENGINE=，仍然会创建InnoDB表。
### Recent Improvements for InnoDB Tables
如果你有MySQL 5.1或者早期版本中使用InnoDB的经验，可以在Section 14.2.4.2, “InnoDB Performance and Scalability Enhancements” 及 Section 14.2.5, “InnoDB Features for Flexibility, Ease of Use and Reliability”中得到最新的InnoDB增强功能。下面对其进行了一些简介：
* 你可以压缩表及其关联的索引。
* 你可以在创建或者删除索引时得到比之前对性能及可用性更小的影响。
* 截断表操作的速度很快，并且会节省出操作系统空间而不是使用系统表空间时只节省出InnoDB的可用空间。
* 如果使用了DYNAMIC行格式，BLOB及大文本的储存分布会更加合适。
* 你可以通过 INFORMATION_SCHEMA 来监视储存引擎的内部工作。
* 你可以通过performance_schema 来监视储存引擎的性能的详细信息。
* 有许多对性能的提升。尤其是崩溃恢复，当数据库重启时会使所有数据保持完整性，是快速并且值得信赖的。（现在已经远快于以前用户使用的InnoDB）数据库越大，对速度的提升越明显。
大部分新特性是自动的，或者最多需要设置一个选项。详细信息可以参考Section 14.2.4.2, “InnoDB Performance and Scalability Enhancements”，对于InnoDB特定的特性，可以参见 Section 8.5, “Optimizing for InnoDB Tables”。高级用户可以参考 Section 14.2.6, “InnoDB Startup Options and System Variables”。
### Testing and Benchmarking with InnoDB as Default Storage Engine
从MySQL 5.1乃至更早版本到MySQL 5.5乃至更新的版本，你都可以预测是否你的数据库或程序使用InnoDB来作为默认储存引擎是否会产生错误。为早期的MySQL设置默认储存引擎为InnoDB，可以在命令行添加default-storage-engine=InnoDB或者在my.cnf文件中的[mysqld]部分添加 default-storage-engine=innodb。然后重启数据库。
只有修改默认储存引擎后创建的新表才会使用新设的默认储存引擎。运行你的程序安装程序并且适当地设置你的程序。然后运行所有的功能来保证所有数据的加载，查询，修改都工作正常。如果一个表需要MyISAM特定的特性，你将会收到一个错误，可以把ENGINE=MyISAM添加到 CREATE TABLE语句中来解决这个问题。（例如，需要全文搜索的表必须使用MyISAM而不是InnoDB）
如果你没有一个确定储存引擎的基准，你只是单纯想要预测表在InnoDB引擎2下是如何工作的，执行ALTER TABLE table_name ENGINE=InnoDB; 命令或者运行如下命令来复制一个原始表：
    #CREATE TABLE InnoDB_Table (...) ENGINE=InnoDB AS SELECT * FROM MyISAM_Table;
在MySQL5.5及更高版本中，InnoDB的性能已经得到极大的提升，为了测试实际工作中的性能，安装最新的MySQL服务器然后运行基准测试。
测试整个程序生命周期，从安装，大量使用到服务器重启。当数据库繁忙时，杀死服务器进程来模拟服务器断电，然后在重启服务器之后验证数据是否都恢复了。
测试所有的复制设置，尤其是你在主服务器及备服务器之间使用了不同的服务器版本及选项时。
### Verifying that InnoDB is the Default Storage Engine
为了知道InnoDB处于什么样的状态，无论你是在做早期版本的MySQL的测试还是最新版本的完全测试：
* 执行语句SHOW ENGINES；来查看所有的储存引擎。确认DEFAULT在InnoDB行上。
* 如果没有见到InnoDB，那你得到的是一个没有编译进去InnoDB的mysqld程序，你需要重新下载一个InnoDB程序。
* 如果提供了InnoDB但被禁用了，在启动选项及配置文件中检查skip-innodb选项。
## 14.2.1.2. Configuring InnoDB
